<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《程序员自我修养:链接、装载与库》第三章 目标文件有什么？</title>
      <link href="/2024/03/27/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-%E9%93%BE%E6%8E%A5%E3%80%81%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93%E3%80%8B%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/03/27/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-%E9%93%BE%E6%8E%A5%E3%80%81%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93%E3%80%8B%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>编译器编译源代码后生成的文件叫做目标文件。</p><h1 id="3-1目标文件的格式"><a href="#3-1目标文件的格式" class="headerlink" title="3.1目标文件的格式"></a>3.1目标文件的格式</h1><p>windows下的可执行格式是PE文件，Linux则是ELF，它们都是COFF格式而来。</p><p>目标文件就是源代码编译后但未进行链接的那些中间文件。</p><p>动态链接库(.ddl)(.so)和静态链接库(.lib)(.a)都按照可执行文件存储。</p><p>静态链接库可理解成多个目标文件捆绑在一起的包。</p><p>下面是ELF文件相关的一个总结图，建议看看。</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/books_1_3_1.jpg"></p><p>随后书下面就讲了一些 目标文件和可执行文件的小历史 这里不做概括</p><p>COFF的主要贡献就是在目标文件中引入了段的机制。</p><h1 id="3-2目标文件是什么样的"><a href="#3-2目标文件是什么样的" class="headerlink" title="3.2目标文件是什么样的?"></a>3.2目标文件是什么样的?</h1><p><strong>目标文件</strong>其实已经是二进制文件了。里面有机器指令代码和数据。</p><p>当然它<strong>还有链接时需要的一些信息，比如符号表，调试信息，字符串等</strong>。</p><p>一般目标文件将这些信息按照不同的属性，<strong>以“节”的形式存储</strong>，有时候也叫做“段”。节与节之间唯一的区别就是ELF的链接视图和装载视图的时候，此处节和段都叫段。</p><p><strong>编译后的机器指令通常放在代码段（.text)，全局变量和局部静态变量放在数据段(.data)。</strong></p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/books_1_3_2.jpg"></p><p>从上图可以看到，<strong>ELF文件开头是“文件头”</strong>，它描述了整个文件的属性（包括是否可执行、静态链接还是动态、入口地址、目标硬件、目标操作系统）<strong>其中还包括一个段表</strong>，<strong>是描述文件中各个段的数组（描述各个段在文件的偏移和属性）。</strong></p><p>值得一提的是，初始化的全局变量和局部静态变量保存在data段；未初始化的全局变量和局部静态变量保存在bss段。但是本来它们应该在data段的，但是因为没初始化，都是0，程序不给存放数据0预留空间，所以此时bss段只是给它们预留位置而已。</p><p>总的来说，程序指令去了text代码段，程序数据去了data和bss段。</p><hr><p>把文件分开来放的好处:</p><ol><li>程序被装载后，数据和指令将分别被映射到两个虚拟内存区域  </li><li>对于CPU来说，它们有着极为强大的缓存体系（有必要提高缓存的命中率）。</li><li>当程序运行多个该程序的副本时，指令只用在一个地方读取，程序的其他数据就可以共享，以用来节省空间。</li></ol><h1 id="3-3挖掘SimpleSection-o"><a href="#3-3挖掘SimpleSection-o" class="headerlink" title="3.3挖掘SimpleSection.o"></a>3.3挖掘SimpleSection.o</h1><p>这里是用readelf来分析文件的格式，笔者只是简单总结一下学到的东西，就不做赘述，建议跟着原文看一遍（P61开始）</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/books_1_3_3.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -h SimpleSection.o</span><br></pre></td></tr></table></figure><p>-h是把ELF各个段的基本信息打印出来，-x可以把更多信息打印出来。</p><p>这里多了打印出来除了上面提到的段的话，还有三个段(.rodata)只读数据段，(.comment)注释信息段，（.note.GNU-stack）堆栈提示段（此处是0，暂且忽略它）。此ELF文件事实上存在的段就只有text，data，rodata，comment这四个段了。</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/books_1_3_4.jpg"></p><h2 id="3-3-1-代码段"><a href="#3-3-1-代码段" class="headerlink" title="3.3.1 代码段"></a>3.3.1 代码段</h2><p>主要是对着格式分析,此处不再赘诉</p><h2 id="3-3-2数据段和只读数据段"><a href="#3-3-2数据段和只读数据段" class="headerlink" title="3.3.2数据段和只读数据段"></a>3.3.2数据段和只读数据段</h2><p>主要是对着格式分析,此处不再赘诉</p><hr><p>“rodata”存放只读数据,语义上支持了C++的const关键字，又保证了程序安全性。另外再某些嵌入式平台下，有些存储区域是采用只读存储器的，如ROM，这样将“.rodata”段放在该存储区域中就可以保证程序访问存储器的正确性。</p><p>另外值得一提的是，有时候编译器会把字符串常量放到data段，可以试试把文件名改成.cpp，然后用各种MSVC编译器编译一下</p><p>然后后面根据它展示的内容，小小讲到了大小端序，在本书的附录有详细介绍，到时候去看。</p><h2 id="3-3-3BSS段"><a href="#3-3-3BSS段" class="headerlink" title="3.3.3BSS段"></a>3.3.3BSS段</h2><p>上面说过，bss段存放未初始化的全局变量和局部静态变量。</p><p>通过bss段的符号是否被定义，是否存放在目标文件的BSS段，引出了“弱符号和强符号和common块”这两个概念，在下一章会讨论这个问题。</p><p>编译器优化有时候会给我们分析系统软件背后的机制带来很多在障碍，使很多问题不能够一目了然，本书尽量避开优化过程，还原机制和原理本身</p><h2 id="3-3-4其他段"><a href="#3-3-4其他段" class="headerlink" title="3.3.4其他段"></a>3.3.4其他段</h2><p>这张图片帮忙说了很多，一下子概括了整整一小节的内容，后仅做补充</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/books_1_3_5.jpg"></p><h3 id="自定义段"><a href="#自定义段" class="headerlink" title="自定义段"></a>自定义段</h3><p>有些时候我们可能希望变量或者某部分代码放到指定的段去，实现某些特定功能。比如为了满足某些硬件的内存和I&#x2F;O地址布局，或者是像Linux操作系统内核中用来完成一些初始化和用户空间复制时出现页错误异常等。</p><p>GCC提供了一个扩展机制，使得程序员可以指定变量所处的段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((section(<span class="string">&quot;FOO&quot;</span>))) <span class="type">int</span> global=<span class="number">42</span></span><br><span class="line">__attribute__((section(<span class="string">&quot;BAR&quot;</span>))) <span class="type">void</span> foo()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在全局变量或者函数之前加入“<strong>attribute</strong>((section(“name”)))”属性，就可以把相应的变量和函数放到以“name”作为段名的段中。</p><h1 id="3-4ELF文件结构描述"><a href="#3-4ELF文件结构描述" class="headerlink" title="3.4ELF文件结构描述"></a>3.4ELF文件结构描述</h1><p>先放ELF文件结构预览图</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/books_1_3_6.jpg"></p><p>ELF目标文件格式最前面是ELF文件头（包含了整个文件的基本属性，比如ELF文件版本、目标机器型号、程序入口地址等）紧接着是ELF各个段。</p><p><strong>其中与ELF中和段的重要结构就是段表（SHtable），表中描述了（段名，段长度，偏移，读写权限以及其他）段的属性。</strong></p><h2 id="3-4-1文件头"><a href="#3-4-1文件头" class="headerlink" title="3.4.1文件头"></a>3.4.1文件头</h2><p>直接上图</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/books_1_3_7.jpg"></p><p>ELF文件头定义了ELF魔数、文件机器字节长度、数据存储方式、版本、运行平台、ABI版本、ELF重定位类型、硬件平台、硬件平台版本、入口地址、程序头入口和长度、段表的位置和长度及段的数量等。</p><p>ELF文件头结构以及相关常数被定义在“&#x2F;usr&#x2F;include&#x2F;elf.h”里，<strong>ELF有32和64位的版本。不同版本的成员大小不一样，但是ELF文件头内容基本上一样</strong>，它们文件头分别叫做“Elf32_Ehdr”和“Elf64_Ehdr”。“elf.h”使用typedef定义了一套自己的变量体系。</p><p>一下是Elfxx_Ehdr的结构体图</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/books_1_3_8.jpg"></p><p>然后较详细介绍了ELF头部结构体一些成员的含义，比如ELF魔数、ELF_type，系统一般通过ELF_type来判断它是ET_REL，ET_EXEC，ET_DYN这三种之一的文件。</p><details class="lake-collapse"><summary id="u4c678d99"><span class="ne-text">ELF头部结构体一些成员的含义</span></summary><p id="u60014499" class="ne-p" style="margin: 0; padding: 0; min-height: 24px"><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/books_1_3_15.png" width="1025" id="u5587b1b1" class="ne-image"></p><p id="ubd04a8f1" class="ne-p" style="margin: 0; padding: 0; min-height: 24px"><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/books_1_3_16.png" width="1006" id="u32a9dd32" class="ne-image"></p></details><h2 id="3-4-2段表"><a href="#3-4-2段表" class="headerlink" title="3.4.2段表"></a>3.4.2段表</h2><p><strong>段表存放段的基本属性的结构</strong>，位置由ELF文件头的“e_shoff”成员决定。</p><p>我们可以看ELF文件段表的基本内容</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/books_1_3_9.jpg"></p><p>段表的结构比较简单，它是一个以“Elf32_Shdr”（也叫段描述符）结构体为元素的数组。每个结构体意味着一个段的信息。ELF段表第一个元素是无效的段描述符。</p><p>“Elf32_Shdr”被定义在”&#x2F;usr&#x2F;include&#x2F;elf.h”，如图:</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/books_1_3_10.png"></p><details class="lake-collapse"><summary id="u86eb7fea"><span class="ne-text">各个成员含义如下</span></summary><p id="u75baa19b" class="ne-p" style="margin: 0; padding: 0; min-height: 24px"><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/books_1_3_11.png" width="576" id="u9500522c" class="ne-image"></p></details><hr><p>这里简单说一下段的标志位，表示该段在进程虚拟地址空间的属性，比如是否可写，是否可执行等。</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/books_1_3_12.png"></p><hr><p>然后再简单说一下段的链接信息(sh_link、sh_info)</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/books_1_3_13.png"></p><h2 id="3-4-3重定位表"><a href="#3-4-3重定位表" class="headerlink" title="3.4.3重定位表"></a>3.4.3重定位表</h2><p>如果一个段的类型是”SHT_REL”，也就是说它是一个<strong>重定位表</strong>，对于每个需要重定位的段都有一个相应的重定位表</p><p>比如”.rel.text”就是对”.text”的重定位表。此时sh_link表示符号表的下标，sh_info表示它作用域哪个段。</p><p>下一章静态链接过程的时候，再细细分析。</p><h2 id="3-4-4字符串表"><a href="#3-4-4字符串表" class="headerlink" title="3.4.4字符串表"></a>3.4.4字符串表</h2><p>一般字符串表在ELF文件中也以段的形式存储，常见的段名是“.strtab”或者“.shstrtab”。分别代表“字符串表”和“段表字符串表”。</p><h1 id="3-5链接的接口——符号"><a href="#3-5链接的接口——符号" class="headerlink" title="3.5链接的接口——符号"></a>3.5链接的接口——符号</h1><p>在链接中，目标文件的相互拼接实际上是目标文件之间对地址的引用，就是对函数和变量地址的引用，我们将<strong>函数和变量统称为符号</strong>，函数名和变量名就是符号名。</p><p>每个目标文件都有一个相应的符号表(Symbol Table)，每个符号都有一个值，叫符号值，对于函数和变量来说，这就是它们的地址。</p><p>还有几种不常用到的符号：定义在本目标文件的全局符号、段名(它的值就是段的起始地址)、本目标文件引用的全局符号、局部符号、行号信息（目标文件指令和源代码中代码行对应的关系）。</p><h2 id="3-5-1-ELF符号结构"><a href="#3-5-1-ELF符号结构" class="headerlink" title="3.5.1 ELF符号结构"></a>3.5.1 ELF符号结构</h2><p>elf符号表往往是个段，段名“.symtab”。</p><p>符号表结构是一个Elf32_Sym结构的数组</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/books_1_3_14.png"></p><p>符号绑定st_info，低4位表示符号类型。高28位表示符号绑定信息，有局部，全局符号还有弱引用。</p><p>符号所在段st_shndx，定义在本目标文件中，表示<strong>符号所在段 在段表 中的下标。</strong></p><p><strong>其他详细建议看书</strong></p><h2 id="3-5-2-特殊符号"><a href="#3-5-2-特殊符号" class="headerlink" title="3.5.2 特殊符号"></a>3.5.2 特殊符号</h2><p>使用ld作为链接器来链接生成可执行文件时，它会为我们定义很多特殊符号，这些符号不是我们定义的，但我们可以使用它，这些符号叫做特殊符号。详细看书</p><h2 id="3-5-3-符号修饰和函数签名"><a href="#3-5-3-符号修饰和函数签名" class="headerlink" title="3.5.3 符号修饰和函数签名"></a>3.5.3 符号修饰和函数签名</h2><p>相当于同一个函数名在不同函数位置中，或者不同返回类型，或者我们的一些函数和库重名，会有一些修饰区分它们，大概就是这样，详细看书。</p><h2 id="3-5-4-extern“C”"><a href="#3-5-4-extern“C”" class="headerlink" title="3.5.4 extern“C”"></a>3.5.4 extern“C”</h2><p>c++为了和C兼容，C++有一个声明和定义C符号的关键字“extern”</p><p>详细看书</p><h2 id="3-5-5-弱符号和强符号"><a href="#3-5-5-弱符号和强符号" class="headerlink" title="3.5.5 弱符号和强符号"></a>3.5.5 弱符号和强符号</h2><p>对于C&#x2F;C++语言来说，<strong>编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号。</strong></p><p>也可以用GCC的“<strong>attribute</strong>((weak))”</p><p><strong>注意：强符号和弱符号都是针对定义来说的，不是针对符号的引用</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> ext;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> weak;</span><br><span class="line"><span class="type">int</span> strong = <span class="number">1</span>;</span><br><span class="line">_attribute_((weak)) weak2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，weak和 weak2 是弱符号， strong和 main 是强符号，而ext 既非强符号也非弱符号，因为它只是一个外部变量的引用。</p><details class="lake-collapse"><summary id="u805012ca"><span class="ne-text">针对强弱符号的概念，链接器会按如下规则处理和选择被多次定义的全局不好：</span></summary><ul class="ne-ul" style="margin: 0; padding-left: 23px"><li id="u61fcc03b" data-lake-index-type="0"><span class="ne-text">** 规则1：**不允许强符号被多次定义(即不同的目标文件不能有同名的强符号)；如果有多个强符号定义，则链接器包符号重复定义错误。</span></li><li id="ub79db9da" data-lake-index-type="0"><span class="ne-text">** 规则2：** 如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选择强符号。</span></li><li id="u023ddd23" data-lake-index-type="0"><span class="ne-text">** 规则3：** 如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。</span></li></ul><p id="u2d5f085f" class="ne-p" style="margin: 0; padding: 0; min-height: 24px"><span class="ne-text">同样对于符号名的引用也分为强引用和弱引用，强引用表示如果找不到符号定义会报错，弱引用不报错，默认为0或某个特殊值。</span></p><p id="u380c2145" class="ne-p" style="margin: 0; padding: 0; min-height: 24px"><span class="ne-text"><br></span><span class="ne-text">链接：https://www.jianshu.com/p/31108b62f81d</span></p></details><p>同样对于符号名的引用也分为强引用和弱引用，强引用表示如果找不到符号定义会报错，弱引用不报错，默认为0或某个特殊值。</p><h1 id="3-6-调试信息"><a href="#3-6-调试信息" class="headerlink" title="3.6 调试信息"></a>3.6 调试信息</h1><p>如果我们GCC编译的时候加上“-g”参数，编译器产生的目标文件里面加上调试信息，可以用readelf工具查看，目标文件里面多了很多“debug”的段</p><p>我们可以用“strip”命令来去掉ELF的调试信息</p><h1 id="3-7-完"><a href="#3-7-完" class="headerlink" title="3.7 完"></a>3.7 完</h1>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> books-reading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/03/27/hello-world/"/>
      <url>/2024/03/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
